{
  "name": "iSAQB e.V. CPSA-F Self Assessment",
  "id": "iSAQB_CPSA-F",
  "url": "https://github.com/isaqb-org",
  "description": "International Software Architecture Qualification Board Certified Professional for Software Architecture Foundation Level Mock Exam Self Assessment",
  "competence_aspects": {
    "basics": {
      "name": "basics",
      "id": "basics",
      "description": "Basics",
      "facets": [
        {
          "name": "Discuss Definitions of Software Architecture (R1)",
          "id": "1-01",
          "description": "\n\nSoftware architects know several definitions of software architecture (incl. ISO 42010/IEEE 1471, SEI, Booch etc.) and can name their similarities:\n\n* components/building blocks with interfaces and relationships\n* building blocks as a general term, components as a special form thereof\n* structures, cross-cutting concepts, principles\n* architecture decisions and their consequences on the entire systems and its lifecycle\n\n"
        },
        {
          "name": "Understand and Explain the Goals and Benefits of Software Architecture (R1)",
          "id": "1-02",
          "description": "\n\n\nSoftware architects can justify the following essential goals and benefits of software architecture:\n\n* support the design, implementation, maintenance, and operation of systems\n* achieve functional requirements or ensure that they can be met\n* achieve requirements such as reliability, maintainability, changeability, security, energy efficiency etc.\n* ensure that the system's structures and concepts are understood by all relevant stakeholders\n* systematically reduce complexity\n* specify architecturally relevant guidelines for implementation and operation\n \n"
        },
        {
          "name": "Understand Software Architecture as Part of the Software Lifecycle (R2)",
          "id": "1-03",
          "description": "\n\nSoftware architects understand their tasks and can integrate their results into the overall lifecycle of IT systems.\nThey can:\n\n* identify the consequences of changes in requirements, technologies, or the system environment in relation to software architecture\n* elaborate on relationships between IT-systems and the supported business and operational processes\n\n"
        },
        {
          "name": "Understand Software Architects' Tasks and Responsibilities (R1)",
          "id": "1-04",
          "description": "\nSoftware architects are responsible for meeting requirements and creating the architecture design of a solution.\nDepending on the actual approach or process model used, they must align this responsibility with the overall responsibilities of project management and/or other roles.\n\nTasks and responsibilities of software architects:\n\n* clarify and scrutinize requirements and constraints, and refine them if necessary,\n  including _required features_ and _required constraints_\n* decide how to decompose the system into building blocks, while determining dependencies and interfaces between the building blocks\n* determine and decide on cross-cutting concepts (for instance persistence, communication, GUI etc.)\n* communicate and document software architecture based on views, architectural patterns, cross-cutting and technical concepts\n* accompany the realization and implementation of the architecture; integrate feedback from relevant stakeholders into the architecture if necessary; review and ensure the consistency of source code and software architecture\n* analyze and evaluate software architecture, especially with respect to risks that involve meeting the requirements, see <<LG-4-3>> and <<LG-4-4>>,\n* identify, highlight, and justify the consequences of architectural decisions to other stakeholders\n\nThey should independently recognize the necessity of iterations in all tasks and point out possibilities for appropriate and relevant feedback.\n\n"
        },
        {
          "name": "Relate the Role of Software Architects to Other Stakeholders (R1)",
          "id": "1-05",
          "description": "\nSoftware architects are able to explain their role. \nThey should adapt their contribution to a software development in a specific context and in relation to other stakeholders and organizational units, in particular to:\n\n* product management and product owners\n* project managers\n* requirement engineers (requirements- or business analysts, requirements managers, system analysts, business owners, subject-matter experts, etc.)\n* developers\n* quality assurance and testers\n* IT operators and administrators (applies primarily to production environment or data centers for information systems),\n* hardware developers\n* enterprise architects and architecture board members\n\n"
        },
        {
          "name": "Can Explain the Correlation between Development Approaches and Software Architecture (R2)",
          "id": "1-06",
          "description": "\n\n* software architects are able to explain the influence of iterative approaches on architectural decisions (with regard to risks and predictability).\n* due to inherent uncertainty, software architects often have to work and make decisions iteratively. To do so, they have to systematically obtain feedback from other stakeholders.\n\n"
        },
        {
          "name": "Differentiate between Short- and Long-Term Goals (R2)",
          "id": "1-07",
          "description": "\n\nSoftware architects can explain potential conflicts between short-term and long-term goals, in order to find a suitable solution for all stakeholders\n\n"
        },
        {
          "name": "Distinguish Explicit Statements and Implicit Assumptions (R1)",
          "id": "1-08",
          "description": "\n\nSoftware architects:\n\n* should explicitly present assumptions or prerequisites, therefore avoiding implicit assumptions\n* know that implicit assumptions can lead to potential misunderstandings between stakeholders\n\n"
        },
        {
          "name": "Responsibilities of Software Architects within the Greater Architectural Context (R3)",
          "id": "1-09",
          "description": "\n\nThe focus of the iSAQB CPSA Foundation Level is on structures and concepts of individual software systems.\n\nIn addition, software architects are familiar with other architectural domains, for example:\n\n* enterprise IT architecture: Structure of application landscapes\n* business and process architecture: Structure of, among other things, business processes\n* information architecture: cross-system structure and use of information and data\n* infrastructure or technology architecture: Structure of the technical infrastructure, hardware, networks, etc.\n* hardware or processor architecture (for hardware-related systems)\n\nThese architectural domains are not the content focus of CPSA-F.\n"
        },
        {
          "name": "Differentiate Types of IT Systems (R3)",
          "id": "1-10",
          "description": "\n\nSoftware architects know different types of IT systems, for example:\n\n* information systems\n* decision support, data warehouse or business intelligence systems\n* mobile systems\n* _cloud native_ systems (refer to <<cncf>>)\n* batch processes or systems\n* systems based upon machine learning or artificial intelligence\n* hardware-related systems; here they understand the necessity of hardware/software co-design (temporal and content-related dependencies of hardware and software design)\n\n"
        },
        {
          "name": "Challenges of Distributed Systems (R3)",
          "id": "1-11",
          "description": "\n\nSoftware architects are able to:\n\n* identify distribution in a given software architecture\n* analyze consistency criteria for a given business problem\n* explain causality of events in a distributed system\n\nSoftware architects know:\n\n* communication may fail in a distributed system\n* limitations regarding consistency in real-world databases\n* what the \"split-brain\" problem is and why it is difficult\n* that it is impossible to determine the temporal order of events in a distributed system\n"
        }
      ]
    },
    "design": {
      "name": "design",
      "id": "design",
      "description": "Design",
      "facets": [
        {
          "name": "Select and Use Approaches and Heuristics for Architecture Development (R1,R3)",
          "id": "2-01",
          "description": "\nSoftware architects are able to name, explain, and use fundamental approaches of architecture development, for example:\n\n* top-down and bottom-up approaches to design (R1)\n* view-based architecture development (R1)\n* iterative and incremental design (R1)\n** necessity of iterations, especially when decision-making is affected by uncertainties (R1)\n** necessity of feedback on design decisions (R1)\n* domain-driven design, see <<evans>> (R3)\n* evolutionary architecture, see <<ford>> (R3)\n* global analysis, see <<hofmeister>> (R3) \n* model-driven architecture (R3)\n\n"
        },
        {
          "name": "Design Software Architectures (R1)",
          "id": "2-02",
          "description": "\n\nSoftware architects are able to:\n\n* design and appropriately communicate and document software architectures based upon known functional and quality requirements for software systems that are neither safety- nor business-critical\n* make structure-relevant decisions regarding system decomposition and building-block structure and deliberately design dependencies between building blocks\n* recognize and justify interdependencies and trade-offs of design decisions\n* explain the terms _black box_ and _white box_ and apply them purposefully\n* apply stepwise refinement and specify building blocks\n* design architecture views, especially building-block view, runtime view and deployment view\n* explain the consequences of these decisions on the corresponding source code\n* separate technical and domain-related elements of architectures and justify these decisions\n* identify risks related to architecture decisions.\n\n"
        },
        {
          "name": "Identify and Consider Factors Influencing Software Architecture (R1-R3)",
          "id": "2-03",
          "description": "\n\n\nSoftware architects are able to clarify and consider requirements (including constraints that restrict their decisions).\nThey understand that their decisions can lead to additional requirements (including constraints) on the system being designed, its architecture, or the development process. \n\n\nThey should recognize and account for the impact of:\n\n* product-related requirements such as (R1)\n** functional requirements\n** quality requirements\n\n\n* technological constraints such as \n** existing or planned hardware and software infrastructure (R1)\n** technological constraints on data structures and interfaces (R2)\n** reference architectures, libraries, components, and frameworks (R1)\n** programming languages (R2)\n\n* organizational constraints such as\n** organizational structure of the development team and of the customer (R1), in particular Conway's law (R2).\n** company and team cultures (R3)\n** partnerships and cooperation agreements (R2)\n** standards, guidelines, and process models (e.g. approval and release processes) (R2)\n** available resources like budget, time, and staff (R1)\n** availability, skill set, and commitment of staff (R1)\n\n* regulatory constraints such as (R2)\n** local and international legal constraints\n** contract and liability issues\n** data protection\u200b and privacy laws\n** compliance issues or obligations to provide burden of proof\u200b\n\n* trends such as (R3)\n** market trends\n** technology trends (e.g. blockchain, microservices)\n** methodology trends (e.g. agile)\n** (potential) impact of further stakeholder concerns and mandated design decisions\n\nSoftware architects are able to describe how those factors can influence design decisions and can elaborate on the consequences of changing influencing factors by providing examples for some of them (R2).\n\n"
        },
        {
          "name": "Design and Implement Cross-Cutting Concepts (R1)",
          "id": "2-04",
          "description": "\n\nSoftware architects are able to:\n\n* explain the significance of such cross-cutting concepts\n* decide on and design cross-cutting concepts, for example persistence, communication, GUI, error handling, concurrency, energy efficiency\n* identify and assess potential interdependencies between these decisions.\n\nSoftware architects know that such cross-cutting concepts may be re-used throughout the system.\n\n"
        },
        {
          "name": "Describe, Explain and Appropriately Apply Important Solution Patterns (R1, R3)",
          "id": "2-05",
          "description": "\n\n\nSoftware architects know:\n\n* various architectural patterns and can apply them when appropriate\n* that patterns are a way to achieve certain qualities for given problems and requirements within given contexts\n* that various categories of patterns exist (R3)\n* additional sources for patterns related to their specific technical or application domain (R3)\n\n\nSoftware architects can explain and provide examples for the following patterns (R1):\n\n* _layers_:\n** abstraction layers hide details, example: ISO/OSI network layers, or \"hardware abstraction layer\". See https://en.wikipedia.org/wiki/Hardware_abstraction\n** another interpretation are Layers to (physically) separate functionality or responsibility, see https://en.wikipedia.org/wiki/Multitier_architecture\n\n* _pipes and filters_: representative for data flow patterns, breaking down stepwise processing into a series of processing-activities (\"Filters\") and associated data transport/buffering capabilities (\"Pipes\").\n* _microservices_ split applications into separate executables that communicate via a network\n* _dependency injection_ as a possible solution for the Dependency-Inversion-Principle <<newman>>\n\n\nSoftware architects can explain several of the following patterns, explain their relevance for concrete systems, and provide examples. (R3)\n\n* _blackboard_: handle problems that cannot be solved by deterministic algorithms but require diverse knowledge\n* _broker_:  responsible for coordinating communication between provider(s) and consumer(s), applied in distributed systems. Responsible for forwarding requests and/or transmitting results and exceptions\n* _combinator_ (synonym: closure of operations), for domain object of type T, look for operations with both input and output type T. See <<yorgey>>\n* _CQRS_ (Command-Query-Responsibility-Segregation): separates read from write concerns in information systems. Requires some context on database-/persistence technology to understand the different properties and requirements of \"read\" versus \"write\" operations\n* _event sourcing_:  handle operations on data by a sequence of events, each of which is recorded in an append-only store\n* _interpreter_: represent domain object or DSL as syntax, provide function implementing a semantic interpretation of domain object separately from domain object itself\n* integration and messaging patterns (e.g. from <<hohpe>>)\n* the MVC (Model View Controller), MVVM (Model View ViewModel), MVU (Model View Update), PAC (Presentation Abstraction Control) family of patterns, separating external representation (view) from data, services and their coordination\n* interfacing patterns like Adapter, Facade, Proxy. Such patterns help in integration of subsystems and/or simplification of dependencies. Architects should know that these patterns can be used independent of (object) technology\n** _adapter_: decouple consumer and provider - where the interface of the provider does not exactly match that of the consumer. The Adapter decouples one party from interface-changes in the other\n** _facade_: simplifies usage of a provider for consumer(s) by providing simplified access\n** _proxy_: an intermediate between consumer and provider, enabling temporal decoupling, caching of results, controlling access to the provider etc.\n* _observer_: An interested object (observer) registers with another\n  object (the subject) so that the subject notifies the observer upon changes.\n* _plug-in_: extend the behaviour of a component\n* _ports & adapters_ (syn. Onion-Architecture, Hexagonal-Architecture, Clean-Architecture): concentrate domain logic in the center of the system, have connections to the outside world (database, UI) at the edges, dependencies only outside-in, never inside-out <<lange21>> <<martin17>>\n* _remote procedure call_: make a function or algorithm execute in a different address space\n* _SOA_ (Service-Oriented Architecture): an approach to provide abstract services rather than concrete implementations to users of the system to promote reuse of services across departments and between companies\n* _template and strategy_: make specific algorithms flexible by encapsulating them\n* _visitor_: separate data-structure traversal from specific processing\n\nSoftware architects know essential sources for architectural patterns, such as POSA (e.g. <<buschmanna>>) and PoEAA (<<fowler>>) (for information systems) (R3).\n\n"
        },
        {
          "name": "Explain and Use Design Principles (R1-R3)",
          "id": "2-06",
          "description": "\n\nSoftware architects are able to explain what design principles are.\nThey can outline their general objectives and applications with regard to software architecture. (R2)\n\nSoftware architects are able to:\n\n* explain the design principles listed below and can illustrate them with examples\n* explain how those principles are to be applied\n* explain how the requirements determine which principles should be applied\n* explain the impact of design principles on the implementation\n* analyze source code and architecture designs to evaluate whether these design principles have been applied or should be applied\n\n**Abstraction** (R1)\n\n* in the sense of a means for deriving useful generalizations\n* as a design technique, where building blocks are dependent on the abstractions rather than depending on implementations\n* interfaces as abstractions\n\n**Modularization** (R1-R3)\n\n* information hiding and encapsulation (R1)\n* separation of concerns - SoC (R1)\n* loose, but functionally sufficient, coupling (R1) of building blocks, see <<LG-2-7, LG 2-7>>\n* high cohesion (R1)\n* SOLID principles (R1-R3), which have, to a certain extent, relevance at the architectural level\n** S:\u00a0Single responsibility principle (R1) and its relation to SoC\n** O: Open/closed principle (R1)\n** L:\u00a0Liskov substitution principle (R3) as a way to achieve consistency and conceptual integrity in OO design\n** I:\u00a0Interface segregation principle (R2), including its relation to <<LG-2-9, LG 2-9>>\n** D:\u00a0Dependency inversion principle (R1) by means of interfaces or similar abstractions\n\n**Conceptual integrity** (R2)\n\n* meaning uniformity (homogeneity, consistency) of solutions for similar problems (R2)\n* as a means to achieve the principle of least surprise (R3)\n\n**Simplicity** (R1-R2)\n\n* as a means to reduce complexity (R1)\n* as the driving factor behind KISS (R3) and YAGNI (R3)\n\n**Expect errors** (R1-R2)\n\n* as a means to design for robust and resilient systems (R1)\n* as a generalization of the robustness principle (_Postel's law_) (R2)\n\n**Other principles** (R3)\n\nSoftware architects know other principles (such as CUPID, see <<nygard-cupid>>), and can apply them.\n"
        },
        {
          "name": "Manage Dependencies between Building Blocks (R1)",
          "id": "2-07",
          "description": "\n\nSoftware architects understand dependencies and coupling between building blocks and can use them in a targeted manner. They:\n\n* know and understand different types of dependencies of building blocks (e.g. coupling via use/delegation, messaging/events, composition, creation, inheritance, temporal coupling, coupling via data, data types or hardware)\n* understand how dependencies increase coupling\n* can use such types of coupling in a targeted manner and can assess the consequences of such dependencies\n* know and can apply possibilities to reduce or eliminate coupling, for example:\n** patterns (see <<LG-2-5, LG 2-5>>)\n** fundamental design principles (see <<LG-2-6, LG 2-6>>)\n** externalization of dependencies, i.e. defining concrete dependencies at installation- or runtime, for example by using _Dependency Injection_.\n\n"
        },
        {
          "name": "Achieve Quality Requirements with Appropriate Approaches and Techniques (R1)",
          "id": "2-08",
          "description": "\n\n\nSoftware architects understand and consider the considerable influence of quality requirements in architecture and design decisions, e.g. for:\n\n* efficiency, runtime performance\n* availability\n* maintainability, modifiability, extensibility, adaptability\n* energy efficiency\n\nThey can:\n\n* explain and apply solution options, _Architectural Tactics_, suitable practices as well as technical possibilities to achieve important quality requirements of software systems (different for embedded systems or information systems)\n* identify and communicate possible trade-offs between such solutions and their associated risks\n\n\n"
        },
        {
          "name": "Design and Define Interfaces (R1-R3)",
          "id": "2-09",
          "description": "\n\nSoftware architects know about the importance of interfaces. They are able to design or specify interfaces between architectural building blocks as well as external interfaces between the system and elements outside of the system.\n\nThey know: \n\n* desired characteristics of interfaces and can use them in the design:\n** easy to learn, easy to use, easy to extend\n** hard to misuse\n** functionally complete from the perspective of users or building blocks using them.\n* the necessity to treat internal and external interfaces differently\n* different approaches for implementing interfaces (R3):\n** resource oriented approach (REST, Representational State Transfer)\n** service oriented approach (see WS-*/SOAP-based web services.\n\n"
        },
        {
          "name": "Know Fundamental Principles of Software Deployment (R3)",
          "id": "2-10",
          "description": "\n\n\nSoftware architects:\n\n* know that software deployment is the process of making new or updated software available to its users\n* are able to name and explain fundamental concepts of software deployment, for example:\n** automated deployments\n** repeatable builds\n** consistent environments (e.g. use immutable and disposable infrastructure)\n** put everything under version-control\n** releases are easy-to-undo\n\n\n"
        }
      ]
    },
    "documentation": {
      "name": "documentation",
      "id": "documentation",
      "description": "Documentation",
      "facets": [
        {
          "name": "Explain and Consider the Requirements of Technical Documentation (R1)",
          "id": "3-01",
          "description": "\nSoftware architects know the requirements of technical documentation and can consider and fulfil them when documenting systems:\n\n* understandability, correctness, efficiency, appropriateness, maintainability\n* form, content, and level of detail tailored to the stakeholders\n\nThey know that only the target audiences can assess the understandability of technical documentation.\n\n"
        },
        {
          "name": "Describe and Communicate Software Architectures (R1-R3)",
          "id": "3-02",
          "description": "\n\nSoftware architects use documentation to support the design, implementation and further development (also called _maintenance_ or _evolution_) of systems (R2)\n\nSoftware architects are able to (R1):\n\n* document and communicate architectures for corresponding stakeholders, thereby addressing different target groups, e.g. management, development teams, QA, other software architects, and possibly additional stakeholders\n* consolidate and harmonise the style and content of contributions from different groups of authors\n* develop and implement measures to support the convergence of written and verbal communication, and balance one against the other appropriately\n\nSoftware architects know (R1):\n\n* the benefits of template-based documentation\n* that various properties of documentation depend on specific properties of the system, its requirements, risks, development process, organization or other factors.\n\nFor example, software architects can adjust the following documentation characteristics according to the situation (R3):\n\n* the amount and level of detail of documentation needed\n* the documentation format\n* the accessibility of the documentation\n* formality of documentation (e.g. diagrams compliant to a meta model or simple drawings)\n* formal reviews and sign-off processes for documentation\n\n\n"
        },
        {
          "name": "Explain and Apply Notations/Models to Describe Software Architecture (R2-R3)",
          "id": "3-03",
          "description": "\n\nSoftware architects know at least the following UML (see <<uml>>) diagrams to describe architectural views:\n\n* class, package, component (all R2) and composite-structure diagrams (R3)\n* deployment diagrams (R2)\n* sequence and activity diagrams (R2)\n* state machine diagrams (R3)\n\nSoftware architects know alternative notations to UML diagrams, for example: (R3)\n\n* Archimate, see <<archimate>>\n* for runtime views for example flow charts, numbered lists or business-process-modeling-notation (BPMN).\n\n"
        },
        {
          "name": "Explain and Use Architectural Views (R1)",
          "id": "3-04",
          "description": "\nSoftware architects are able to use the following architectural views:\n\n* context view \n* building block or component view (composition of software building blocks) \n* runtime view (dynamic view, interaction between software building blocks at runtime, state machines) \n* deployment view (hardware and technical infrastructure as well as the mapping of software building blocks onto the infrastructure)\n\n"
        },
        {
          "name": "Explain and Apply Context View of Systems (R1)",
          "id": "3-05",
          "description": "\nSoftware architects are able to:\n\n* depict the context of systems, e.g. in the form of context diagrams with explanations\n* represent external interfaces of systems in the context view\n* differentiate business and technical context.\n\n"
        },
        {
          "name": "Document and Communicate Cross-Cutting Concepts (R2)",
          "id": "3-06",
          "description": "\n\nSoftware architects are able to adequately document and communicate typical cross-cutting concepts (synonym: _principles_, _aspects_), e. g., persistence, workflow management, UI, deployment/integration, logging.\n\n"
        },
        {
          "name": "Describe Interfaces (R1)",
          "id": "3-07",
          "description": "\n\nSoftware architects are able to describe and specify both internal and external interfaces.\n\n"
        },
        {
          "name": "Explain and Document Architectural Decisions (R1-R2)",
          "id": "3-08",
          "description": "\n\nSoftware architects are able to:\n\n* systematically take, justify, communicate, and document architectural decisions\n* identify, communicate, and document interdependencies between design decisions\n\nSoftware architects know about Architecture-Decision-Records (ADR, see <<nygard>>) and can apply these to document decisions (R2).\n\n"
        },
        {
          "name": "Know Additional Resources and Tools for Documentation (R3)",
          "id": "3-09",
          "description": "\n\nSoftware architects know:\n\n* basics of several published frameworks for the description of software architectures, for example:\n** ISO/IEEE-42010 (formerly 1471), see <<iso42010>>\n** arc42, see <<arc42>>\n** C4, see <<brownc4>>\n** FMC, see <<fmc>>\n* ideas and examples of checklists for the creation, documentation, and testing of software architectures\n* possible tools for creating and maintaining architectural documentation\n\n"
        }
      ]
    },
    "examples": {
      "name": "examples",
      "id": "examples",
      "description": "Examples",
      "facets": [
        {
          "name": "Know the Relation between Requirements, Constraints, and Solutions (R3)",
          "id": "5-01",
          "description": "\nSoftware architects are expected to recognize and comprehend the correlation between requirements and constraints, and the chosen solutions using at least one example.\n\n"
        },
        {
          "name": "Know the Rationale of a Solution's Technical Implementation (R3)",
          "id": "5-02",
          "description": "\nSoftware architects understand the technical realization (implementation, technical concepts, products used, architectural decisions, solution strategies) of at least one solution.\n\n"
        }
      ]
    },
    "quality": {
      "name": "quality",
      "id": "quality",
      "description": "Quality",
      "facets": [
        {
          "name": "Discuss Quality Models and Quality Characteristics (R1)",
          "id": "4-01",
          "description": "\n\nSoftware architects can explain:\n\n* the concept of quality and quality characteristics  (based on e.g. <<iso25010>> or <<bass>>)\n* generic quality models (such as <<iso25010>>, <<bass>>, or <<q42>>)\n* correlations and trade-offs of quality characteristics, for example:\n** configurability versus reliability\n** memory requirements versus performance efficiency\n** security versus usability\n** runtime flexibility versus maintainability.\n\n"
        },
        {
          "name": "Clarify Quality Requirements for Software Architectures (R1)",
          "id": "4-02",
          "description": "\n\nSoftware architects can:\n\n* clarify and formulate specific quality requirements for the software to be developed and its architectures, for example in the form of scenarios and quality trees\n* explain and apply scenarios and quality trees.\n\n"
        },
        {
          "name": "Qualitative Analysis of Software Architectures (R2-R3)",
          "id": "4-03",
          "description": "\nSoftware architects:\n\n* know methodical approaches for the qualitative analysis of software architectures (R2), for example, as specified by ATAM (R3);\n* can qualitatively analyze smaller systems (R2)\n* know that the following sources of information can help in the qualitative analysis of architectures (R2):\n** quality requirements, e.g. in the form of quality trees and scenarios\n** architecture documentation\n** architecture and design models\n** source code\n** metrics\n** other documentation of the system, such as requirements, operational or test documentation.\n\n"
        },
        {
          "name": "Quantitative Evaluation of Software Architectures (R2)",
          "id": "4-04",
          "description": "\n\nSoftware architects know approaches for the quantitative analysis and evaluation (measurement) of software.\n\nThey know that:\n\n* quantitative evaluation can help to identify critical parts within systems\n* further information can be helpful for the evaluation of architectures, for example:\n** requirements and architecture documentation\n** source code and related metrics such as lines of code, (cyclomatic) complexity, inbound and outbound dependencies\n** known errors in source code, especially error clusters\n** test cases and test results.\n* the use of a metric as a target can lead to its invalidation (R2), as described, e.g., by Goodhart's law (R3).\n\n"
        }
      ]
    }
  },
  "competence_levels": [
    {
      "name": "Need to Learn",
      "icon": "thumb_down",
      "color_code": "#FF0000",
      "level": 1
    },
    {
      "name": "Need to Lookup",
      "icon": "question_mark",
      "color_code": "#0000FF",
      "level": 2
    },
    {
      "name": "Already Known",
      "icon": "thumb_up",
      "color_code": "#008000",
      "level": 3
    }
  ],
  "element_names": {
    "tree": "Syllabus",
    "aspect": "Chapter",
    "facet": "Learning Goal",
    "level": "Self Assessment"
  }
}