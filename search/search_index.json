{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dynamic_competence_map API Documentation","text":""},{"location":"#dcm.dcm_assessment","title":"<code>dcm_assessment</code>","text":"<p>Created on 2024-01-10</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_assessment.Assessment","title":"<code>Assessment</code>","text":"<p>Assessment for CompetenceTree</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>class Assessment:\n    \"\"\"\n    Assessment for CompetenceTree\n    \"\"\"\n\n    def __init__(\n        self,\n        webserver: NiceGuiWebserver,\n        dcm: DynamicCompetenceMap,\n        learner: Learner,\n        debug: bool = False,\n    ):\n        \"\"\"\n        initialize the assessment\n\n        Args:\n            webserver(NiceguiWebServer): the webserver context\n            dcm(DynamicCompetenceMap): the competence map\n            learner(Learner): the learner to get the self assessment for\n            debug(bool): if True show debugging information\n        \"\"\"\n        self.webserver = webserver\n        self.debug = debug\n        self.reset(dcm=dcm, learner=learner)\n        self.setup_ui()\n\n    def store(self) -&gt; str:\n        \"\"\"\n        Store the current state of\n        the learner's achievements.\n\n        Returns(str): the path to the file\n        \"\"\"\n        file_path = None\n        try:\n            # Serialize the learner object to JSON\n            learner_data_json = self.learner.to_json(indent=2)\n\n            # Determine the file path for storing the learner's data\n            filename = self.learner.file_name + \".json\"\n            file_path = os.path.join(self.webserver.config.storage_path, filename)\n\n            # Write the serialized data to the file\n            with open(file_path, \"w\") as file:\n                file.write(learner_data_json)\n\n            if self.debug:\n                print(f\"Learner data stored in {file_path}\")\n\n        except Exception as ex:\n            self.webserver.handle_exception(ex)\n        return file_path\n\n    def reset(\n        self,\n        dcm: DynamicCompetenceMap,\n        learner: Learner,\n    ):\n        \"\"\"\n            (re)set the assessment\n\n        Args:\n            webserver(NiceguiWebServer): the webserver context\n            dcm(DynamicCompetenceMap): the competence map\n            learner(Learner): the learner to get the self assessment for\n        \"\"\"\n        self.dcm = dcm\n        self.competence_tree = dcm.competence_tree\n        self.learner = learner\n        self.achievement_index = 0\n        # do we need setup the achievements?\n        if self.learner.achievements is None:\n            self.learner.achievements = []\n            self.setup_achievements()\n        self.total = len(self.learner.achievements)\n\n    def clear(self):\n        \"\"\"\n        clear the ui\n        \"\"\"\n        self.container.clear()\n\n    @property\n    def current_achievement(self) -&gt; Achievement:\n        if self.achievement_index &lt; 0 or self.achievement_index &gt; len(\n            self.learner.achievements\n        ):\n            raise ValueError(f\"invalid achievement index {self.achievement_index}\")\n        achievement = self.learner.achievements[self.achievement_index]\n        return achievement\n\n    def setup_achievements(self):\n        \"\"\"\n        Setup achievements based on the competence tree.\n\n        This method iterates over the competence aspects and their facets,\n        constructs a path for each facet, and creates an Achievement instance\n        based on the path. These achievements are then added to the learner's\n        achievements list.\n        \"\"\"\n        for aspect in self.competence_tree.aspects:\n            for area in aspect.areas:\n                self.add_achievement(area.path)\n                for facet in area.facets:\n                    # Construct the path for the facet\n                    self.add_achievement(facet.path)\n\n    def add_achievement(self, path):\n        # Create a new Achievement instance with the constructed path\n        new_achievement = Achievement(\n            path=path,\n        )\n        self.learner.add_achievement(new_achievement)\n\n    def get_index_str(self) -&gt; str:\n        \"\"\"\n        get the current achievement index\n        \"\"\"\n        index_str = f\"{self.achievement_index+1:2}/{self.total:2}\"\n        return index_str\n\n    def setup_ui(self):\n        \"\"\"\n        display my competence Tree elements\n        \"\"\"\n        with ui.grid(columns=1).classes(\"w-full\") as self.container:\n            self.progress_bar = NiceguiProgressbar(\n                total=self.total, desc=\"self assessment\", unit=\"facets\"\n            )\n            self.progress_bar.reset()\n            facet_element_name = (\n                self.competence_tree.element_names.get(\"facet\") or \"facet\"\n            )\n            area_element_name = self.competence_tree.element_names.get(\"area\") or \"area\"\n\n            with ui.row() as self.navigation_row:\n                ui.button(\n                    \"\", icon=\"first_page\", on_click=lambda _args: self.goto(0)\n                ).tooltip(\"to first\")\n                ui.button(\n                    \"\", icon=\"fast_rewind\", on_click=lambda _args: self.step_area(-1)\n                ).tooltip(f\"previous {area_element_name}\")\n                ui.button(\n                    \"\", icon=\"arrow_back\", on_click=lambda _args: self.step(-1)\n                ).tooltip(f\"previous {facet_element_name}\")\n                ui.button(\n                    \"\", icon=\"arrow_forward\", on_click=lambda _args: self.step(1)\n                ).tooltip(f\"next {facet_element_name}\")\n                ui.button(\n                    \"\", icon=\"fast_forward\", on_click=lambda _args: self.step_area(1)\n                ).tooltip(f\"next {area_element_name}\")\n                ui.button(\n                    \"\",\n                    icon=\"last_page\",\n                    on_click=lambda _args: self.goto(self.total - 1),\n                ).tooltip(\"to last\")\n            with ui.row() as self.button_row_row:\n                self.button_row = ButtonRow(\n                    self, self.competence_tree, self.current_achievement\n                )\n            with ui.row() as self.card_row:\n                with ui.card() as self.achievement_view:\n                    self.index_view = ui.label(self.get_index_str())\n                    self.link_view = ui.html()\n                    self.markdown_view = ui.markdown()\n\n    def show_progress(self):\n        \"\"\"\n        Update the progress bar based on the\n        number of achievements with a non-None level value.\n        \"\"\"\n        count = sum(\n            1\n            for achievement in self.learner.achievements\n            if achievement.level is not None\n        )\n        self.progress_bar.total = self.total\n        self.progress_bar.update_value(count)\n\n    async def step_area(self, area_step: int):\n        \"\"\"\n        Step towards the area given in area_step.\n        For example, 1 means next area, -1 means previous area.\n        \"\"\"\n        if area_step == 0:\n            return  # No movement required\n\n        direction = 1 if area_step &gt; 0 else -1\n        area_count = 0\n\n        # Start with the next/previous achievement based on the direction\n        new_index = self.achievement_index + direction\n\n        # Loop through achievements until the desired area count is reached\n        while 0 &lt;= new_index &lt; len(self.learner.achievements):\n            achievement = self.learner.achievements[new_index]\n            element = self.competence_tree.lookup_by_path(achievement.path)\n\n            if isinstance(element, CompetenceArea):\n                area_count += 1\n                if area_count == abs(area_step):\n                    # Found the required area, update the index\n                    self.goto(new_index)\n                    return\n\n            # Move to the next/previous achievement\n            new_index += direction\n\n        # Notify if no more areas in the direction\n        with self.container:\n            ui.notify(\"Reached the end of the areas in this direction.\")\n\n    def goto(self, index: int):\n        self.achievement_index = index\n        self.step(0)\n\n    def step(self, step: int = 0):\n        \"\"\"\n        step with the achievement view\n        \"\"\"\n        self.update_achievement_view(step)\n\n    def update_achievement_view(self, step: int = 0):\n        \"\"\"\n        display the active achievement as the step indicates\n        \"\"\"\n        self.show_progress()\n        if self.achievement_index + step &lt; 0:\n            ui.notify(\"first achievement reached!\")\n            step = 0\n        if self.achievement_index + step &lt; len(self.learner.achievements):\n            self.achievement_index += step\n        else:\n            ui.notify(\"Done!\")\n        self.update_current_achievement_view()\n\n    def update_current_achievement_view(self):\n        \"\"\"\n        show the current achievement\n        \"\"\"\n        self.index_view.text = self.get_index_str()\n        achievement = self.current_achievement\n        self.store()\n        self.webserver.render_dcm(\n            self.dcm,\n            self.learner,\n            selected_paths=[achievement.path],\n            clear_assessment=False,\n        )\n        self.button_row.achievement = achievement\n        self.button_row.set_button_states(achievement)\n        competence_element = self.competence_tree.lookup_by_path(achievement.path)\n        if not competence_element:\n            ui.notify(f\"invalid path: {achievement.path}\")\n            self.markdown_view.content = f\"\u26a0\ufe0f {achievement.path}\"\n        else:\n            if hasattr(competence_element, \"path\"):\n                if competence_element.url:\n                    link = Link.create(competence_element.url, competence_element.path)\n                else:\n                    link = competence_element.path\n            else:\n                link = \"\u26a0\ufe0f - competence element path missing\"\n            self.link_view.content = link\n            description = competence_element.description or \"\"\n            if isinstance(competence_element, CompetenceArea):\n                aspect = competence_element.aspect\n                description = f\"### {aspect.name}\\n\\n**{competence_element.name}**:\\n\\n{description}\"\n            if isinstance(competence_element, CompetenceFacet):\n                area = competence_element.area\n                description = f\"### {area.name}\\n\\n**{competence_element.name}**:\\n\\n{description}\"\n            self.markdown_view.content = description\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.__init__","title":"<code>__init__(webserver, dcm, learner, debug=False)</code>","text":"<p>initialize the assessment</p> <p>Parameters:</p> Name Type Description Default <code>webserver(NiceguiWebServer)</code> <p>the webserver context</p> required <code>dcm(DynamicCompetenceMap)</code> <p>the competence map</p> required <code>learner(Learner)</code> <p>the learner to get the self assessment for</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def __init__(\n    self,\n    webserver: NiceGuiWebserver,\n    dcm: DynamicCompetenceMap,\n    learner: Learner,\n    debug: bool = False,\n):\n    \"\"\"\n    initialize the assessment\n\n    Args:\n        webserver(NiceguiWebServer): the webserver context\n        dcm(DynamicCompetenceMap): the competence map\n        learner(Learner): the learner to get the self assessment for\n        debug(bool): if True show debugging information\n    \"\"\"\n    self.webserver = webserver\n    self.debug = debug\n    self.reset(dcm=dcm, learner=learner)\n    self.setup_ui()\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.clear","title":"<code>clear()</code>","text":"<p>clear the ui</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def clear(self):\n    \"\"\"\n    clear the ui\n    \"\"\"\n    self.container.clear()\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.get_index_str","title":"<code>get_index_str()</code>","text":"<p>get the current achievement index</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def get_index_str(self) -&gt; str:\n    \"\"\"\n    get the current achievement index\n    \"\"\"\n    index_str = f\"{self.achievement_index+1:2}/{self.total:2}\"\n    return index_str\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.reset","title":"<code>reset(dcm, learner)</code>","text":"<pre><code>(re)set the assessment\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>webserver(NiceguiWebServer)</code> <p>the webserver context</p> required <code>dcm(DynamicCompetenceMap)</code> <p>the competence map</p> required <code>learner(Learner)</code> <p>the learner to get the self assessment for</p> required Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def reset(\n    self,\n    dcm: DynamicCompetenceMap,\n    learner: Learner,\n):\n    \"\"\"\n        (re)set the assessment\n\n    Args:\n        webserver(NiceguiWebServer): the webserver context\n        dcm(DynamicCompetenceMap): the competence map\n        learner(Learner): the learner to get the self assessment for\n    \"\"\"\n    self.dcm = dcm\n    self.competence_tree = dcm.competence_tree\n    self.learner = learner\n    self.achievement_index = 0\n    # do we need setup the achievements?\n    if self.learner.achievements is None:\n        self.learner.achievements = []\n        self.setup_achievements()\n    self.total = len(self.learner.achievements)\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.setup_achievements","title":"<code>setup_achievements()</code>","text":"<p>Setup achievements based on the competence tree.</p> <p>This method iterates over the competence aspects and their facets, constructs a path for each facet, and creates an Achievement instance based on the path. These achievements are then added to the learner's achievements list.</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def setup_achievements(self):\n    \"\"\"\n    Setup achievements based on the competence tree.\n\n    This method iterates over the competence aspects and their facets,\n    constructs a path for each facet, and creates an Achievement instance\n    based on the path. These achievements are then added to the learner's\n    achievements list.\n    \"\"\"\n    for aspect in self.competence_tree.aspects:\n        for area in aspect.areas:\n            self.add_achievement(area.path)\n            for facet in area.facets:\n                # Construct the path for the facet\n                self.add_achievement(facet.path)\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.setup_ui","title":"<code>setup_ui()</code>","text":"<p>display my competence Tree elements</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    display my competence Tree elements\n    \"\"\"\n    with ui.grid(columns=1).classes(\"w-full\") as self.container:\n        self.progress_bar = NiceguiProgressbar(\n            total=self.total, desc=\"self assessment\", unit=\"facets\"\n        )\n        self.progress_bar.reset()\n        facet_element_name = (\n            self.competence_tree.element_names.get(\"facet\") or \"facet\"\n        )\n        area_element_name = self.competence_tree.element_names.get(\"area\") or \"area\"\n\n        with ui.row() as self.navigation_row:\n            ui.button(\n                \"\", icon=\"first_page\", on_click=lambda _args: self.goto(0)\n            ).tooltip(\"to first\")\n            ui.button(\n                \"\", icon=\"fast_rewind\", on_click=lambda _args: self.step_area(-1)\n            ).tooltip(f\"previous {area_element_name}\")\n            ui.button(\n                \"\", icon=\"arrow_back\", on_click=lambda _args: self.step(-1)\n            ).tooltip(f\"previous {facet_element_name}\")\n            ui.button(\n                \"\", icon=\"arrow_forward\", on_click=lambda _args: self.step(1)\n            ).tooltip(f\"next {facet_element_name}\")\n            ui.button(\n                \"\", icon=\"fast_forward\", on_click=lambda _args: self.step_area(1)\n            ).tooltip(f\"next {area_element_name}\")\n            ui.button(\n                \"\",\n                icon=\"last_page\",\n                on_click=lambda _args: self.goto(self.total - 1),\n            ).tooltip(\"to last\")\n        with ui.row() as self.button_row_row:\n            self.button_row = ButtonRow(\n                self, self.competence_tree, self.current_achievement\n            )\n        with ui.row() as self.card_row:\n            with ui.card() as self.achievement_view:\n                self.index_view = ui.label(self.get_index_str())\n                self.link_view = ui.html()\n                self.markdown_view = ui.markdown()\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.show_progress","title":"<code>show_progress()</code>","text":"<p>Update the progress bar based on the number of achievements with a non-None level value.</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def show_progress(self):\n    \"\"\"\n    Update the progress bar based on the\n    number of achievements with a non-None level value.\n    \"\"\"\n    count = sum(\n        1\n        for achievement in self.learner.achievements\n        if achievement.level is not None\n    )\n    self.progress_bar.total = self.total\n    self.progress_bar.update_value(count)\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.step","title":"<code>step(step=0)</code>","text":"<p>step with the achievement view</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def step(self, step: int = 0):\n    \"\"\"\n    step with the achievement view\n    \"\"\"\n    self.update_achievement_view(step)\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.step_area","title":"<code>step_area(area_step)</code>  <code>async</code>","text":"<p>Step towards the area given in area_step. For example, 1 means next area, -1 means previous area.</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>async def step_area(self, area_step: int):\n    \"\"\"\n    Step towards the area given in area_step.\n    For example, 1 means next area, -1 means previous area.\n    \"\"\"\n    if area_step == 0:\n        return  # No movement required\n\n    direction = 1 if area_step &gt; 0 else -1\n    area_count = 0\n\n    # Start with the next/previous achievement based on the direction\n    new_index = self.achievement_index + direction\n\n    # Loop through achievements until the desired area count is reached\n    while 0 &lt;= new_index &lt; len(self.learner.achievements):\n        achievement = self.learner.achievements[new_index]\n        element = self.competence_tree.lookup_by_path(achievement.path)\n\n        if isinstance(element, CompetenceArea):\n            area_count += 1\n            if area_count == abs(area_step):\n                # Found the required area, update the index\n                self.goto(new_index)\n                return\n\n        # Move to the next/previous achievement\n        new_index += direction\n\n    # Notify if no more areas in the direction\n    with self.container:\n        ui.notify(\"Reached the end of the areas in this direction.\")\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.store","title":"<code>store()</code>","text":"<p>Store the current state of the learner's achievements.</p> <p>Returns(str): the path to the file</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def store(self) -&gt; str:\n    \"\"\"\n    Store the current state of\n    the learner's achievements.\n\n    Returns(str): the path to the file\n    \"\"\"\n    file_path = None\n    try:\n        # Serialize the learner object to JSON\n        learner_data_json = self.learner.to_json(indent=2)\n\n        # Determine the file path for storing the learner's data\n        filename = self.learner.file_name + \".json\"\n        file_path = os.path.join(self.webserver.config.storage_path, filename)\n\n        # Write the serialized data to the file\n        with open(file_path, \"w\") as file:\n            file.write(learner_data_json)\n\n        if self.debug:\n            print(f\"Learner data stored in {file_path}\")\n\n    except Exception as ex:\n        self.webserver.handle_exception(ex)\n    return file_path\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.update_achievement_view","title":"<code>update_achievement_view(step=0)</code>","text":"<p>display the active achievement as the step indicates</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def update_achievement_view(self, step: int = 0):\n    \"\"\"\n    display the active achievement as the step indicates\n    \"\"\"\n    self.show_progress()\n    if self.achievement_index + step &lt; 0:\n        ui.notify(\"first achievement reached!\")\n        step = 0\n    if self.achievement_index + step &lt; len(self.learner.achievements):\n        self.achievement_index += step\n    else:\n        ui.notify(\"Done!\")\n    self.update_current_achievement_view()\n</code></pre>"},{"location":"#dcm.dcm_assessment.Assessment.update_current_achievement_view","title":"<code>update_current_achievement_view()</code>","text":"<p>show the current achievement</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def update_current_achievement_view(self):\n    \"\"\"\n    show the current achievement\n    \"\"\"\n    self.index_view.text = self.get_index_str()\n    achievement = self.current_achievement\n    self.store()\n    self.webserver.render_dcm(\n        self.dcm,\n        self.learner,\n        selected_paths=[achievement.path],\n        clear_assessment=False,\n    )\n    self.button_row.achievement = achievement\n    self.button_row.set_button_states(achievement)\n    competence_element = self.competence_tree.lookup_by_path(achievement.path)\n    if not competence_element:\n        ui.notify(f\"invalid path: {achievement.path}\")\n        self.markdown_view.content = f\"\u26a0\ufe0f {achievement.path}\"\n    else:\n        if hasattr(competence_element, \"path\"):\n            if competence_element.url:\n                link = Link.create(competence_element.url, competence_element.path)\n            else:\n                link = competence_element.path\n        else:\n            link = \"\u26a0\ufe0f - competence element path missing\"\n        self.link_view.content = link\n        description = competence_element.description or \"\"\n        if isinstance(competence_element, CompetenceArea):\n            aspect = competence_element.aspect\n            description = f\"### {aspect.name}\\n\\n**{competence_element.name}**:\\n\\n{description}\"\n        if isinstance(competence_element, CompetenceFacet):\n            area = competence_element.area\n            description = f\"### {area.name}\\n\\n**{competence_element.name}**:\\n\\n{description}\"\n        self.markdown_view.content = description\n</code></pre>"},{"location":"#dcm.dcm_assessment.ButtonRow","title":"<code>ButtonRow</code>","text":"<p>A button row for selecting competence levels to document achievements from  a CompetenceTree.</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>class ButtonRow:\n    \"\"\"\n    A button row for selecting competence levels\n    to document achievements from  a CompetenceTree.\n    \"\"\"\n\n    def __init__(\n        self,\n        assessment: \"Assessment\",\n        competence_tree: CompetenceTree,\n        achievement: Achievement = None,\n    ):\n        \"\"\"\n        Construct a button row for the competence levels of the given CompetenceTree.\n\n        Args:\n            assessment (Assessment): The Assessment instance.\n            competence_tree (CompetenceTree): The Competence Tree to display buttons for.\n            achievement (Achievement): The current achievement of the learner.\n        \"\"\"\n        self.assessment = assessment\n        self.competence_tree = competence_tree\n        self.achievement = achievement\n        self.setup_buttons()\n        self.set_button_states(achievement)\n\n    def setup_buttons(self):\n        \"\"\"\n        Create buttons for each competence level defined in the CompetenceTree.\n        \"\"\"\n        self.buttons = {}\n        with ui.row() as self.row:\n            for level in self.competence_tree.levels:\n                # generate a button to represent the level\n                button_label = level.name\n                if level.utf8_icon:\n                    button_label = f\"{level.utf8_icon} {level.name}\"\n                button = ui.button(\n                    button_label,\n                    icon=level.icon,\n                    color=level.color_code,\n                    on_click=lambda _args, l=level.level: self.handle_selection(l),\n                ).tooltip(level.description)\n                self.buttons[level.level] = button\n\n    def set_button_states(self, achievement: Achievement):\n        \"\"\"\n        Set the state of buttons based on the given achievement.\n\n        Args:\n            achievement (Achievement): The current achievement of the learner.\n        \"\"\"\n        # If no achievement or level is set, enable all buttons\n        if achievement is None or achievement.level is None:\n            for button in self.buttons.values():\n                button.enable()\n                button.visible = True\n        else:\n            # Enable only the button corresponding to the current level and disable others\n            for level, button in self.buttons.items():\n                if level == achievement.level:\n                    button.enable()\n                    button.visible = True\n                else:\n                    button.disable()\n                    button.visible = False\n\n    def handle_selection(self, selected_level: int):\n        \"\"\"\n        handle the selected level\n\n        Args:\n            selected_level(int): the selected level\n        \"\"\"\n        # Check if the same level is selected again,\n        # then reset the selection\n        if self.achievement.level == selected_level:\n            self.achievement.level = None\n        else:\n            self.achievement.level = selected_level\n            # Get the current time in UTC\n            current_time_utc = datetime.now(timezone.utc)\n\n            # Convert the current time to ISO format\n            date_assessed_iso = current_time_utc.isoformat()\n\n            # Assign it to self.achievement.date_assessed_iso\n            self.achievement.date_assessed_iso = date_assessed_iso\n\n        self.set_button_states(self.achievement)\n        # refresh the ui\n        self.row.update()\n        # show achievement_view\n        step = 1 if self.achievement.level else 0\n        self.assessment.step(step)\n</code></pre>"},{"location":"#dcm.dcm_assessment.ButtonRow.__init__","title":"<code>__init__(assessment, competence_tree, achievement=None)</code>","text":"<p>Construct a button row for the competence levels of the given CompetenceTree.</p> <p>Parameters:</p> Name Type Description Default <code>assessment</code> <code>Assessment</code> <p>The Assessment instance.</p> required <code>competence_tree</code> <code>CompetenceTree</code> <p>The Competence Tree to display buttons for.</p> required <code>achievement</code> <code>Achievement</code> <p>The current achievement of the learner.</p> <code>None</code> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def __init__(\n    self,\n    assessment: \"Assessment\",\n    competence_tree: CompetenceTree,\n    achievement: Achievement = None,\n):\n    \"\"\"\n    Construct a button row for the competence levels of the given CompetenceTree.\n\n    Args:\n        assessment (Assessment): The Assessment instance.\n        competence_tree (CompetenceTree): The Competence Tree to display buttons for.\n        achievement (Achievement): The current achievement of the learner.\n    \"\"\"\n    self.assessment = assessment\n    self.competence_tree = competence_tree\n    self.achievement = achievement\n    self.setup_buttons()\n    self.set_button_states(achievement)\n</code></pre>"},{"location":"#dcm.dcm_assessment.ButtonRow.handle_selection","title":"<code>handle_selection(selected_level)</code>","text":"<p>handle the selected level</p> <p>Parameters:</p> Name Type Description Default <code>selected_level(int)</code> <p>the selected level</p> required Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def handle_selection(self, selected_level: int):\n    \"\"\"\n    handle the selected level\n\n    Args:\n        selected_level(int): the selected level\n    \"\"\"\n    # Check if the same level is selected again,\n    # then reset the selection\n    if self.achievement.level == selected_level:\n        self.achievement.level = None\n    else:\n        self.achievement.level = selected_level\n        # Get the current time in UTC\n        current_time_utc = datetime.now(timezone.utc)\n\n        # Convert the current time to ISO format\n        date_assessed_iso = current_time_utc.isoformat()\n\n        # Assign it to self.achievement.date_assessed_iso\n        self.achievement.date_assessed_iso = date_assessed_iso\n\n    self.set_button_states(self.achievement)\n    # refresh the ui\n    self.row.update()\n    # show achievement_view\n    step = 1 if self.achievement.level else 0\n    self.assessment.step(step)\n</code></pre>"},{"location":"#dcm.dcm_assessment.ButtonRow.set_button_states","title":"<code>set_button_states(achievement)</code>","text":"<p>Set the state of buttons based on the given achievement.</p> <p>Parameters:</p> Name Type Description Default <code>achievement</code> <code>Achievement</code> <p>The current achievement of the learner.</p> required Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def set_button_states(self, achievement: Achievement):\n    \"\"\"\n    Set the state of buttons based on the given achievement.\n\n    Args:\n        achievement (Achievement): The current achievement of the learner.\n    \"\"\"\n    # If no achievement or level is set, enable all buttons\n    if achievement is None or achievement.level is None:\n        for button in self.buttons.values():\n            button.enable()\n            button.visible = True\n    else:\n        # Enable only the button corresponding to the current level and disable others\n        for level, button in self.buttons.items():\n            if level == achievement.level:\n                button.enable()\n                button.visible = True\n            else:\n                button.disable()\n                button.visible = False\n</code></pre>"},{"location":"#dcm.dcm_assessment.ButtonRow.setup_buttons","title":"<code>setup_buttons()</code>","text":"<p>Create buttons for each competence level defined in the CompetenceTree.</p> Source code in <code>dcm/dcm_assessment.py</code> <pre><code>def setup_buttons(self):\n    \"\"\"\n    Create buttons for each competence level defined in the CompetenceTree.\n    \"\"\"\n    self.buttons = {}\n    with ui.row() as self.row:\n        for level in self.competence_tree.levels:\n            # generate a button to represent the level\n            button_label = level.name\n            if level.utf8_icon:\n                button_label = f\"{level.utf8_icon} {level.name}\"\n            button = ui.button(\n                button_label,\n                icon=level.icon,\n                color=level.color_code,\n                on_click=lambda _args, l=level.level: self.handle_selection(l),\n            ).tooltip(level.description)\n            self.buttons[level.level] = button\n</code></pre>"},{"location":"#dcm.dcm_chart","title":"<code>dcm_chart</code>","text":"<p>Created on 2024-01-12</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_chart.DcmChart","title":"<code>DcmChart</code>","text":"<p>a Dynamic competence map chart</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>class DcmChart:\n    \"\"\"\n    a Dynamic competence map chart\n    \"\"\"\n\n    def __init__(self, dcm: DynamicCompetenceMap):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.dcm = dcm\n\n    def prepare_and_add_inner_circle(\n        self, config, competence_tree: CompetenceTree, lookup_url: str = None\n    ):\n        \"\"\"\n        prepare the SVG markup generation and add\n        the inner_circle\n        \"\"\"\n        self.lookup_url = (\n            competence_tree.lookup_url if competence_tree.lookup_url else lookup_url\n        )\n\n        svg = SVG(config)\n        self.svg = svg\n        config = svg.config\n        # center of circle\n        self.cx = config.width // 2\n        self.cy = (config.total_height - config.legend_height) // 2\n        ringspec = competence_tree.ring_specs.get(\"tree\")\n        self.tree_radius = ringspec.outer_ratio * config.width / 2\n\n        self.circle_config = competence_tree.to_svg_node_config(\n            x=self.cx, y=self.cy, width=self.tree_radius\n        )\n        svg.add_circle(config=self.circle_config)\n        if ringspec.text_mode != \"empty\":\n            svg.add_text(\n                self.cx,\n                self.cy,\n                competence_tree.short_name,\n                text_anchor=\"middle\",\n                center_v=True,\n                fill=\"white\",\n            )\n        return svg\n\n    def generate_svg(\n        self,\n        filename: Optional[str] = None,\n        learner: Optional[Learner] = None,\n        config: Optional[SVGConfig] = None,\n        text_mode: str = \"empty\",\n    ) -&gt; str:\n        \"\"\"\n        Generate the SVG markup and optionally save it to a file. If a filename is given, the method\n        will also save the SVG to that file. The SVG is generated based on internal state not shown here.\n\n        Args:\n            filename (str, optional): The path to the file where the SVG should be saved. Defaults to None.\n            learner(Learner): the learner to show the achievements for\n            config (SVGConfig, optional): The configuration for the SVG canvas and legend. Defaults to default values.\n            text_mode(str): text display mode\n        Returns:\n            str: The SVG markup.\n        \"\"\"\n        if config is None:\n            config = SVGConfig(\n                with_popup=True\n            )  # Use default configuration if none provided\n        svg_markup = self.generate_svg_markup(\n            self.dcm.competence_tree,\n            learner=learner,\n            config=config,\n            text_mode=text_mode,\n        )\n        if filename:\n            self.save_svg_to_file(svg_markup, filename)\n        return svg_markup\n\n    def get_element_config(self, element: CompetenceElement) -&gt; SVGNodeConfig:\n        \"\"\"\n        get a configuration for the given element\n\n        Args:\n            element(CompetenceElement): the element\n\n        Return:\n            SVGNodeConfig: an SVG Node configuration\n        \"\"\"\n        if element is None:\n            element_config = SVGNodeConfig(x=self.cx, y=self.cy, fill=\"white\")\n            return element_config\n        element_url = (\n            element.url\n            if element.url\n            else (\n                f\"{self.lookup_url}/description/{element.path}\"\n                if self.lookup_url is not None\n                else None\n            )\n        )\n        show_as_popup = element.url is None\n        element_config = element.to_svg_node_config(\n            url=element_url,\n            show_as_popup=show_as_popup,\n            x=self.cx,\n            y=self.cy,\n        )\n        return element_config\n\n    def get_stacked_segment(\n        self,\n        level: int,\n        total_levels: int,\n        segment: DonutSegment,\n        element_config: SVGNodeConfig,\n    ) -&gt; Tuple[DonutSegment, SVGNodeConfig]:\n        \"\"\"\n        Calculate the stacked segment for a given level.\n\n        Args:\n            level (int): The current level for which to calculate the segment.\n            total_levels (int): The total number of levels.\n            segment (DonutSegment): The original donut Segment.\n            element_config (SVGNodeConfig): The element configuration.\n\n        Returns:\n            Tuple[DonutSegment, SVGNodeConfig]:\n                The calculated stacked segment and its configuration for the given level.\n\n        \"\"\"\n        level_color = self.dcm.competence_tree.get_level_color(level)\n        stack_element_config = copy.deepcopy(element_config)\n        stack_element_config.fill = level_color\n        ratio = level / total_levels\n        relative_radius = (segment.outer_radius - segment.inner_radius) * ratio\n        stacked_segment = copy.deepcopy(segment)\n        stacked_segment.outer_radius = segment.inner_radius + relative_radius\n        return stacked_segment, stack_element_config\n\n    def add_donut_segment(\n        self,\n        svg: SVG,\n        element: CompetenceElement,\n        segment: DonutSegment,\n        level_color=None,\n        achievement_level=None,\n        ringspec: RingSpec = None,\n    ) -&gt; DonutSegment:\n        \"\"\"\n        create a donut segment for the\n        given competence element and add it\n        to the given SVG\n\n        if level color is available an achievement\n        needs to be potentially shown\n        \"\"\"\n        element_config = self.get_element_config(element)\n        # make sure we show the text on the original segment\n        text_segment = copy.deepcopy(segment)\n\n        if level_color:\n            element_config.fill = level_color  # Set the color\n        if element and element.path in self.selected_paths:\n            element_config.element_class = \"selected\"\n            element_config.color = \"blue\"\n        # in case we need to draw an achievement\n        total_levels = self.dcm.competence_tree.total_valid_levels\n\n        if achievement_level is None:\n            result = svg.add_donut_segment(config=element_config, segment=segment)\n        else:\n            if not self.dcm.competence_tree.stacked_levels:\n                ratio = achievement_level / total_levels\n                relative_radius = (segment.outer_radius - segment.inner_radius) * ratio\n                segment.outer_radius = segment.inner_radius + relative_radius\n                result = svg.add_donut_segment(config=element_config, segment=segment)\n            else:\n                # create the stacked segments starting with the highest level\n                for level in range(achievement_level, 0, -1):\n                    stacked_segment, stack_element_config = self.get_stacked_segment(\n                        level, total_levels, segment, element_config\n                    )\n                    # the result will be overriden in the loop so we'll return the innermost\n                    result = svg.add_donut_segment(\n                        config=stack_element_config, segment=stacked_segment\n                    )\n        if element:\n            text_mode = \"empty\"\n            if segment.text_mode:\n                text_mode = segment.text_mode\n            if text_mode != \"empty\":\n                # no autofill please\n                # textwrap.fill(element.short_name, width=20)\n                text = element.short_name\n                self.svg.add_text_to_donut_segment(\n                    text_segment, text, direction=text_mode\n                )\n        # in stacked mode show the level circles\n        # by drawing arcs even if no achievements\n        # are available\n        if ringspec and ringspec.levels_visible:\n            if total_levels:\n                svg.add_element(f\"&lt;!-- arcs for {element.path} --&gt;\")\n                for level in range(total_levels):\n                    stacked_segment, stack_element_config = self.get_stacked_segment(\n                        level, total_levels, segment, element_config\n                    )\n                    fill = \"white\"  # Set the color for unachieved levels\n                    donut_path = svg.get_donut_path(\n                        stacked_segment, radial_offset=1, middle_arc=True\n                    )  # Get the path for the stacked segment\n                    svg.add_element(\n                        f'&lt;path d=\"{donut_path}\" stroke=\"{fill}\" fill=\"none\" stroke-width=\"1.5\" /&gt;'\n                    )  # Draw the path in SVG\n\n        return result\n\n    def generate_donut_segment_for_achievement(\n        self,\n        svg: SVG,\n        learner: Learner,\n        element: CompetenceElement,\n        segment: DonutSegment,\n    ) -&gt; DonutSegment:\n        \"\"\"\n        generate a donut segment for the\n        learner's achievements\n        corresponding to the given path and return it's segment definition\n        \"\"\"\n        achievement = learner.achievements_by_path.get(element.path, None)\n        result = None\n        if achievement and achievement.level:\n            # Retrieve the color for the achievement level\n            level_color = self.dcm.competence_tree.get_level_color(achievement.level)\n\n            if level_color:\n                # set the color and radius of\n                # the segment for achievement\n                # make sure we don't interfere with the segment calculations\n                segment = copy.deepcopy(segment)\n                result = self.add_donut_segment(\n                    svg, element, segment, level_color, achievement.level\n                )\n        return result\n\n    def generate_donut_segment_for_element(\n        self,\n        svg: SVG,\n        element: CompetenceElement,\n        learner: Learner,\n        segment: DonutSegment,\n        ringspec: RingSpec = None,\n    ) -&gt; DonutSegment:\n        \"\"\"\n        generate a donut segment for a given element of\n        the CompetenceTree\n        \"\"\"\n        if segment.outer_radius == 0.0:\n            result = segment\n        else:\n            # Simply create the donut segment without considering the achievement\n            result = self.add_donut_segment(\n                svg=svg, element=element, segment=segment, ringspec=ringspec\n            )\n            # check learner achievements\n            if learner:\n                _learner_segment = self.generate_donut_segment_for_achievement(\n                    svg=svg, learner=learner, element=element, segment=segment\n                )\n        return result\n\n    def generate_pie_elements_for_segments(\n        self,\n        svg: SVG,\n        ct: CompetenceTree,\n        segments: Dict[str, Dict[str, DonutSegment]],\n        learner: Learner,\n    ):\n        \"\"\"\n        Generate pie elements for the competence tree using pre-calculated segments.\n\n        This method will iterate through the provided segments dictionary, using each pre-calculated\n        DonutSegment to generate and render pie elements (e.g., aspects, areas, or facets) based on\n        the learner's achievements.\n\n        Args:\n            svg (SVG): The SVG object where the pie elements will be drawn.\n            ct (CompetenceTree): The competence tree structure.\n            segments (Dict[str, Dict[str, DonutSegment]]): A nested dictionary where the first key is the\n                                                           level name (e.g., 'aspect', 'area', 'facet'),\n                                                           and the second key is an element's path, mapping\n                                                           to its corresponding DonutSegment.\n            learner (Learner): The learner object containing achievement data.\n        \"\"\"\n        for level_name, segment_dict in segments.items():\n            ringspec = ct.ring_specs[level_name]\n            for path, segment in segment_dict.items():\n                element = ct.elements_by_path.get(path, None)\n                if element:\n                    self.generate_donut_segment_for_element(\n                        svg, element, learner, segment=segment, ringspec=ringspec\n                    )\n\n    def create_donut_segment(\n        self,\n        parent_segment: DonutSegment,\n        start_angle: float,\n        end_angle: float,\n        ringspec: RingSpec,\n    ) -&gt; DonutSegment:\n        \"\"\"\n        Creates a new DonutSegment based on the specified parameters, calculating its\n        inner and outer radii based on SVG configuration and ring specifications.\n\n        Args:\n            parent_segment (DonutSegment): The parent segment from which the new segment inherits its center (cx, cy).\n            start_angle (float): The starting angle of the new segment.\n            end_angle (float): The ending angle of the new segment.\n            ringspec (RingSpec): An instance of RingSpec defining the ratios for inner and outer radii, and the text mode.\n\n        Returns:\n            DonutSegment: A new DonutSegment instance configured as specified.\n        \"\"\"\n        # Calculate the actual inner and outer radii based on the SVG config and ringspec ratios\n        inner_radius = self.svg.config.width / 2 * ringspec.inner_ratio\n        outer_radius = self.svg.config.width / 2 * ringspec.outer_ratio\n        # Create a new segment for this element\n        segment = DonutSegment(\n            cx=parent_segment.cx,\n            cy=parent_segment.cy,\n            inner_radius=inner_radius,\n            outer_radius=outer_radius,\n            start_angle=start_angle,\n            end_angle=end_angle,\n            text_mode=ringspec.text_mode,\n        )\n        return segment\n\n    def calculate_sub_segments(\n        self,\n        ct: CompetenceTree,\n        parent_segment: DonutSegment,\n        level_name: str,\n        symmetry_mode: str,\n        elements: List[CompetenceElement],\n        lenient: bool = True,\n    ) -&gt; Dict[str, DonutSegment]:\n        \"\"\"\n        Calculates and returns a dictionary of DonutSegment objects for a given level in the Competence Tree.\n\n        This method divides a parent segment into sub-segments based on the number of elements in the specified level,\n        and assigns each sub-segment to the corresponding element's path.\n\n        Args:\n            ct: An instance of CompetenceTree representing the entire competence structure.\n            parent_segment: A DonutSegment instance representing the parent segment within which the sub-segments will be calculated.\n            level_name: The name of the level (e.g., 'aspect', 'area', 'facet') for which sub-segments are being calculated.\n            symmetry_mode: The symmetry mode ('symmetric' or 'asymmetric') affecting segment calculation.\n            elements: A list of CompetenceElement instances at the current level.\n            lenient (bool): if True symmetry mode will be adjusted to count in case there are no values\n        Returns:\n            A dictionary where keys are element paths and values are DonutSegment instances representing each element's segment in the visualization.\n        \"\"\"\n        ringspec: RingSpec = ct.ring_specs[level_name]\n        sub_segments: Dict[str, DonutSegment] = {}\n        attr_names = {\"time\": \"time\", \"score\": \"max_score\"}\n        if len(elements) == 0:\n            return sub_segments\n        num_zero_none_values = 0\n\n        if symmetry_mode == \"count\":\n            total = len(elements)\n        else:\n            attr_name = attr_names[symmetry_mode]\n            total = 0\n            min_value = float(\n                \"inf\"\n            )  # Initialize to infinity for proper minimum comparison\n\n            # Initial loop to calculate total and count 0/None values\n            for element in elements:\n                value = getattr(element, attr_name)\n                if value in (0, None):\n                    num_zero_none_values += 1\n                else:\n                    total += value\n                    if value &lt; min_value:\n                        min_value = value\n\n        if total == 0 and num_zero_none_values == len(elements):\n            if not lenient:\n                raise ValueError(\n                    \"All element values are 0 or None, cannot divide segment.\"\n                )\n            else:\n                # robust reaction on issue\n                symmetry_mode = \"count\"\n                num_zero_none_values = 0\n                total = len(elements)\n\n        # Correct handling when all values are not 0/None\n        # and therefore  min_value was not updated\n        if num_zero_none_values &gt; 0:\n            # Adjust total value for 0/None values\n            # we use the min_value as a default\n            total += min_value * num_zero_none_values\n\n        start_angle = parent_segment.start_angle\n\n        for element in elements:\n            if symmetry_mode == \"count\":\n                value = 1\n            else:\n                value = getattr(element, attr_name) or min_value\n            proportion = value / total\n            angle_span = (\n                parent_segment.end_angle - parent_segment.start_angle\n            ) * proportion\n            end_angle = start_angle + angle_span\n\n            segment = self.create_donut_segment(\n                parent_segment, start_angle, end_angle, ringspec\n            )\n            sub_segments[element.path] = segment\n            start_angle = end_angle\n\n        return sub_segments\n\n    def calculate_parent_segments(\n        self, segments: Dict[str, DonutSegment], ringspec: RingSpec\n    ) -&gt; Dict[str, DonutSegment]:\n        \"\"\"\n        Aggregates child segments into parent segments, calculating the combined start and end angles\n        for each parent based on its children segments. It uses the `create_donut_segment` function to\n        ensure that newly created parent segments have the correct dimensions according to the specified `ringspec`.\n\n        Args:\n            segments: A dictionary of child segments with paths as keys and DonutSegment objects as values.\n            ringspec: A RingSpec object specifying the dimensions for the newly created parent segments.\n\n        Returns:\n            A dictionary of aggregated parent segments with parent paths as keys and newly created DonutSegment objects as values.\n        \"\"\"\n        parent_segments: Dict[str, DonutSegment] = {}\n\n        for path, segment in segments.items():\n            # Extract the parent path\n            parent_path = \"/\".join(path.split(\"/\")[:-1])\n            if parent_path not in parent_segments:\n                # For a new parent segment, initialize with current segment's angles\n                parent_segments[parent_path] = self.create_donut_segment(\n                    parent_segment=segment,  # Assuming there's logic to determine this correctly\n                    start_angle=segment.start_angle,\n                    end_angle=segment.end_angle,\n                    ringspec=ringspec,\n                )\n            else:\n                # Update existing parent segment's angles\n                parent_segment = parent_segments[parent_path]\n                parent_segment.start_angle = min(\n                    segment.start_angle, parent_segment.start_angle\n                )\n                parent_segment.end_angle = max(\n                    segment.end_angle, parent_segment.end_angle\n                )\n\n        return parent_segments\n\n    def calculate_segments(\n        self, ct: CompetenceTree, tree_segment: DonutSegment\n    ) -&gt; Dict[str, Dict[str, DonutSegment]]:\n        \"\"\"\n        Pre-calculate the donut segments for each level of the competence tree.\n\n        Args:\n            ct: A CompetenceTree instance for which segments are to be calculated.\n            tree_segment: A DonutSegment instance representing the whole competence tree.\n\n        Returns:\n            A nested dictionary where the first-level keys are level names (e.g., 'aspect', 'area', 'facet'),\n            and the second-level keys are element paths with their corresponding DonutSegment objects as values.\n        \"\"\"\n\n        self.level_segments = {\"aspect\": {}, \"area\": {}, \"facet\": {}}\n\n        symmetry_level, symmetry_mode = ct.get_symmetry_spec()\n        symmetry_elements = ct.elements_by_level[symmetry_level]\n        sub_segments = self.calculate_sub_segments(\n            ct, tree_segment, symmetry_level, symmetry_mode, symmetry_elements\n        )\n        self.level_segments[symmetry_level] = sub_segments\n        if symmetry_level == \"facet\":\n            # work from outer level to inner\n            area_segments = self.calculate_parent_segments(\n                sub_segments, ct.ring_specs[\"area\"]\n            )\n            self.level_segments[\"area\"] = area_segments\n            aspect_segments = self.calculate_parent_segments(\n                area_segments, ct.ring_specs[\"aspect\"]\n            )\n            self.level_segments[\"aspect\"] = aspect_segments\n        elif symmetry_level == \"area\":\n            # work from outer level to inner\n            area_segments = sub_segments\n            aspect_segments = self.calculate_parent_segments(\n                area_segments, ct.ring_specs[\"aspect\"]\n            )\n            self.level_segments[\"aspect\"] = aspect_segments\n            # work from middle level to outer\n            for area_path, area_segment in area_segments.items():\n                area = ct.elements_by_path[area_path]\n                facet_segments = self.calculate_sub_segments(\n                    ct, area_segment, \"facet\", symmetry_mode, area.facets\n                )\n                self.level_segments[\"facet\"].update(facet_segments)\n        elif symmetry_level == \"aspect\":\n            # work from inner level to outer\n            for aspect_path, aspect_segment in sub_segments.items():\n                aspect = ct.elements_by_path[aspect_path]\n                area_segments = self.calculate_sub_segments(\n                    ct, aspect_segment, \"area\", symmetry_mode, aspect.areas\n                )\n                self.level_segments[\"area\"].update(area_segments)\n                for area_path, area_segment in area_segments.items():\n                    area = ct.elements_by_path[area_path]\n                    facet_segments = self.calculate_sub_segments(\n                        ct, area_segment, \"facet\", symmetry_mode, area.facets\n                    )\n                    self.level_segments[\"facet\"].update(facet_segments)\n\n        else:\n            raise ValueError(f\"Invalid symmetry_level {symmetry_level}\")\n        return self.level_segments\n\n    def generate_svg_markup(\n        self,\n        competence_tree: CompetenceTree = None,\n        learner: Learner = None,\n        selected_paths: List = [],\n        config: SVGConfig = None,\n        with_java_script: bool = True,\n        text_mode: str = \"empty\",\n        lookup_url: str = \"\",\n    ) -&gt; str:\n        \"\"\"\n        Generate the SVG markup for the given CompetenceTree and Learner. This method\n        creates an SVG representation of the competence map, which visualizes the\n        structure and levels of competencies, along with highlighting the learner's\n        achievements if provided.\n\n        Args:\n            competence_tree (CompetenceTree, optional): The competence tree structure\n                to be visualized. If None, the competence tree of the DcmChart instance\n                will be used. Defaults to None.\n            learner (Learner, optional): The learner whose achievements are to be\n                visualized on the competence tree. If None, no learner-specific\n                information will be included in the SVG. Defaults to None.\n            selected_paths (List, optional): A list of paths that should be highlighted\n                in the SVG. These paths typically represent specific competencies or\n                achievements. Defaults to an empty list.\n            config (SVGConfig, optional): Configuration for the SVG canvas and legend.\n                If None, default configuration settings are used. Defaults to None.\n            text_mode(str): text display mode\n            with_java_script (bool, optional): Indicates whether to include JavaScript\n                in the SVG for interactivity. Defaults to True.\n            lookup_url (str, optional): Base URL for linking to detailed descriptions\n                or information about the competence elements. If not provided, links\n                will not be generated. Defaults to an empty string.\n\n        Returns:\n            str: A string containing the SVG markup for the competence map.\n\n        Raises:\n            ValueError: If there are inconsistencies or issues with the provided data\n                that prevent the creation of a valid SVG.\n        \"\"\"\n        if competence_tree is None:\n            competence_tree = self.dcm.competence_tree\n        self.selected_paths = selected_paths\n\n        competence_tree.calculate_ring_specs(text_mode)\n        svg = self.prepare_and_add_inner_circle(config, competence_tree, lookup_url)\n\n        segment = DonutSegment(\n            cx=self.cx, cy=self.cy, inner_radius=0, outer_radius=self.tree_radius\n        )\n        segments = self.calculate_segments(competence_tree, segment)\n        self.generate_pie_elements_for_segments(\n            svg=svg, ct=competence_tree, segments=segments, learner=learner\n        )\n        # self.generate_pie_elements(\n        #    level=1,\n        #    svg=svg,\n        #    ct=competence_tree,\n        #    parent_element=competence_tree,\n        #    learner=learner,\n        #    segment=segment,\n        # )\n        if svg.config.legend_height &gt; 0:\n            competence_tree.add_legend(svg)\n\n        return svg.get_svg_markup(with_java_script=with_java_script)\n\n    def save_svg_to_file(self, svg_markup: str, filename: str):\n        \"\"\"\n        Save the SVG content to a file\n        \"\"\"\n        with open(filename, \"w\") as file:\n            file.write(svg_markup)\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.__init__","title":"<code>__init__(dcm)</code>","text":"<p>Constructor</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def __init__(self, dcm: DynamicCompetenceMap):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.dcm = dcm\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.add_donut_segment","title":"<code>add_donut_segment(svg, element, segment, level_color=None, achievement_level=None, ringspec=None)</code>","text":"<p>create a donut segment for the given competence element and add it to the given SVG</p> <p>if level color is available an achievement needs to be potentially shown</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def add_donut_segment(\n    self,\n    svg: SVG,\n    element: CompetenceElement,\n    segment: DonutSegment,\n    level_color=None,\n    achievement_level=None,\n    ringspec: RingSpec = None,\n) -&gt; DonutSegment:\n    \"\"\"\n    create a donut segment for the\n    given competence element and add it\n    to the given SVG\n\n    if level color is available an achievement\n    needs to be potentially shown\n    \"\"\"\n    element_config = self.get_element_config(element)\n    # make sure we show the text on the original segment\n    text_segment = copy.deepcopy(segment)\n\n    if level_color:\n        element_config.fill = level_color  # Set the color\n    if element and element.path in self.selected_paths:\n        element_config.element_class = \"selected\"\n        element_config.color = \"blue\"\n    # in case we need to draw an achievement\n    total_levels = self.dcm.competence_tree.total_valid_levels\n\n    if achievement_level is None:\n        result = svg.add_donut_segment(config=element_config, segment=segment)\n    else:\n        if not self.dcm.competence_tree.stacked_levels:\n            ratio = achievement_level / total_levels\n            relative_radius = (segment.outer_radius - segment.inner_radius) * ratio\n            segment.outer_radius = segment.inner_radius + relative_radius\n            result = svg.add_donut_segment(config=element_config, segment=segment)\n        else:\n            # create the stacked segments starting with the highest level\n            for level in range(achievement_level, 0, -1):\n                stacked_segment, stack_element_config = self.get_stacked_segment(\n                    level, total_levels, segment, element_config\n                )\n                # the result will be overriden in the loop so we'll return the innermost\n                result = svg.add_donut_segment(\n                    config=stack_element_config, segment=stacked_segment\n                )\n    if element:\n        text_mode = \"empty\"\n        if segment.text_mode:\n            text_mode = segment.text_mode\n        if text_mode != \"empty\":\n            # no autofill please\n            # textwrap.fill(element.short_name, width=20)\n            text = element.short_name\n            self.svg.add_text_to_donut_segment(\n                text_segment, text, direction=text_mode\n            )\n    # in stacked mode show the level circles\n    # by drawing arcs even if no achievements\n    # are available\n    if ringspec and ringspec.levels_visible:\n        if total_levels:\n            svg.add_element(f\"&lt;!-- arcs for {element.path} --&gt;\")\n            for level in range(total_levels):\n                stacked_segment, stack_element_config = self.get_stacked_segment(\n                    level, total_levels, segment, element_config\n                )\n                fill = \"white\"  # Set the color for unachieved levels\n                donut_path = svg.get_donut_path(\n                    stacked_segment, radial_offset=1, middle_arc=True\n                )  # Get the path for the stacked segment\n                svg.add_element(\n                    f'&lt;path d=\"{donut_path}\" stroke=\"{fill}\" fill=\"none\" stroke-width=\"1.5\" /&gt;'\n                )  # Draw the path in SVG\n\n    return result\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.calculate_parent_segments","title":"<code>calculate_parent_segments(segments, ringspec)</code>","text":"<p>Aggregates child segments into parent segments, calculating the combined start and end angles for each parent based on its children segments. It uses the <code>create_donut_segment</code> function to ensure that newly created parent segments have the correct dimensions according to the specified <code>ringspec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>Dict[str, DonutSegment]</code> <p>A dictionary of child segments with paths as keys and DonutSegment objects as values.</p> required <code>ringspec</code> <code>RingSpec</code> <p>A RingSpec object specifying the dimensions for the newly created parent segments.</p> required <p>Returns:</p> Type Description <code>Dict[str, DonutSegment]</code> <p>A dictionary of aggregated parent segments with parent paths as keys and newly created DonutSegment objects as values.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def calculate_parent_segments(\n    self, segments: Dict[str, DonutSegment], ringspec: RingSpec\n) -&gt; Dict[str, DonutSegment]:\n    \"\"\"\n    Aggregates child segments into parent segments, calculating the combined start and end angles\n    for each parent based on its children segments. It uses the `create_donut_segment` function to\n    ensure that newly created parent segments have the correct dimensions according to the specified `ringspec`.\n\n    Args:\n        segments: A dictionary of child segments with paths as keys and DonutSegment objects as values.\n        ringspec: A RingSpec object specifying the dimensions for the newly created parent segments.\n\n    Returns:\n        A dictionary of aggregated parent segments with parent paths as keys and newly created DonutSegment objects as values.\n    \"\"\"\n    parent_segments: Dict[str, DonutSegment] = {}\n\n    for path, segment in segments.items():\n        # Extract the parent path\n        parent_path = \"/\".join(path.split(\"/\")[:-1])\n        if parent_path not in parent_segments:\n            # For a new parent segment, initialize with current segment's angles\n            parent_segments[parent_path] = self.create_donut_segment(\n                parent_segment=segment,  # Assuming there's logic to determine this correctly\n                start_angle=segment.start_angle,\n                end_angle=segment.end_angle,\n                ringspec=ringspec,\n            )\n        else:\n            # Update existing parent segment's angles\n            parent_segment = parent_segments[parent_path]\n            parent_segment.start_angle = min(\n                segment.start_angle, parent_segment.start_angle\n            )\n            parent_segment.end_angle = max(\n                segment.end_angle, parent_segment.end_angle\n            )\n\n    return parent_segments\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.calculate_segments","title":"<code>calculate_segments(ct, tree_segment)</code>","text":"<p>Pre-calculate the donut segments for each level of the competence tree.</p> <p>Parameters:</p> Name Type Description Default <code>ct</code> <code>CompetenceTree</code> <p>A CompetenceTree instance for which segments are to be calculated.</p> required <code>tree_segment</code> <code>DonutSegment</code> <p>A DonutSegment instance representing the whole competence tree.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[str, DonutSegment]]</code> <p>A nested dictionary where the first-level keys are level names (e.g., 'aspect', 'area', 'facet'),</p> <code>Dict[str, Dict[str, DonutSegment]]</code> <p>and the second-level keys are element paths with their corresponding DonutSegment objects as values.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def calculate_segments(\n    self, ct: CompetenceTree, tree_segment: DonutSegment\n) -&gt; Dict[str, Dict[str, DonutSegment]]:\n    \"\"\"\n    Pre-calculate the donut segments for each level of the competence tree.\n\n    Args:\n        ct: A CompetenceTree instance for which segments are to be calculated.\n        tree_segment: A DonutSegment instance representing the whole competence tree.\n\n    Returns:\n        A nested dictionary where the first-level keys are level names (e.g., 'aspect', 'area', 'facet'),\n        and the second-level keys are element paths with their corresponding DonutSegment objects as values.\n    \"\"\"\n\n    self.level_segments = {\"aspect\": {}, \"area\": {}, \"facet\": {}}\n\n    symmetry_level, symmetry_mode = ct.get_symmetry_spec()\n    symmetry_elements = ct.elements_by_level[symmetry_level]\n    sub_segments = self.calculate_sub_segments(\n        ct, tree_segment, symmetry_level, symmetry_mode, symmetry_elements\n    )\n    self.level_segments[symmetry_level] = sub_segments\n    if symmetry_level == \"facet\":\n        # work from outer level to inner\n        area_segments = self.calculate_parent_segments(\n            sub_segments, ct.ring_specs[\"area\"]\n        )\n        self.level_segments[\"area\"] = area_segments\n        aspect_segments = self.calculate_parent_segments(\n            area_segments, ct.ring_specs[\"aspect\"]\n        )\n        self.level_segments[\"aspect\"] = aspect_segments\n    elif symmetry_level == \"area\":\n        # work from outer level to inner\n        area_segments = sub_segments\n        aspect_segments = self.calculate_parent_segments(\n            area_segments, ct.ring_specs[\"aspect\"]\n        )\n        self.level_segments[\"aspect\"] = aspect_segments\n        # work from middle level to outer\n        for area_path, area_segment in area_segments.items():\n            area = ct.elements_by_path[area_path]\n            facet_segments = self.calculate_sub_segments(\n                ct, area_segment, \"facet\", symmetry_mode, area.facets\n            )\n            self.level_segments[\"facet\"].update(facet_segments)\n    elif symmetry_level == \"aspect\":\n        # work from inner level to outer\n        for aspect_path, aspect_segment in sub_segments.items():\n            aspect = ct.elements_by_path[aspect_path]\n            area_segments = self.calculate_sub_segments(\n                ct, aspect_segment, \"area\", symmetry_mode, aspect.areas\n            )\n            self.level_segments[\"area\"].update(area_segments)\n            for area_path, area_segment in area_segments.items():\n                area = ct.elements_by_path[area_path]\n                facet_segments = self.calculate_sub_segments(\n                    ct, area_segment, \"facet\", symmetry_mode, area.facets\n                )\n                self.level_segments[\"facet\"].update(facet_segments)\n\n    else:\n        raise ValueError(f\"Invalid symmetry_level {symmetry_level}\")\n    return self.level_segments\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.calculate_sub_segments","title":"<code>calculate_sub_segments(ct, parent_segment, level_name, symmetry_mode, elements, lenient=True)</code>","text":"<p>Calculates and returns a dictionary of DonutSegment objects for a given level in the Competence Tree.</p> <p>This method divides a parent segment into sub-segments based on the number of elements in the specified level, and assigns each sub-segment to the corresponding element's path.</p> <p>Parameters:</p> Name Type Description Default <code>ct</code> <code>CompetenceTree</code> <p>An instance of CompetenceTree representing the entire competence structure.</p> required <code>parent_segment</code> <code>DonutSegment</code> <p>A DonutSegment instance representing the parent segment within which the sub-segments will be calculated.</p> required <code>level_name</code> <code>str</code> <p>The name of the level (e.g., 'aspect', 'area', 'facet') for which sub-segments are being calculated.</p> required <code>symmetry_mode</code> <code>str</code> <p>The symmetry mode ('symmetric' or 'asymmetric') affecting segment calculation.</p> required <code>elements</code> <code>List[CompetenceElement]</code> <p>A list of CompetenceElement instances at the current level.</p> required <code>lenient</code> <code>bool</code> <p>if True symmetry mode will be adjusted to count in case there are no values</p> <code>True</code> <p>Returns:     A dictionary where keys are element paths and values are DonutSegment instances representing each element's segment in the visualization.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def calculate_sub_segments(\n    self,\n    ct: CompetenceTree,\n    parent_segment: DonutSegment,\n    level_name: str,\n    symmetry_mode: str,\n    elements: List[CompetenceElement],\n    lenient: bool = True,\n) -&gt; Dict[str, DonutSegment]:\n    \"\"\"\n    Calculates and returns a dictionary of DonutSegment objects for a given level in the Competence Tree.\n\n    This method divides a parent segment into sub-segments based on the number of elements in the specified level,\n    and assigns each sub-segment to the corresponding element's path.\n\n    Args:\n        ct: An instance of CompetenceTree representing the entire competence structure.\n        parent_segment: A DonutSegment instance representing the parent segment within which the sub-segments will be calculated.\n        level_name: The name of the level (e.g., 'aspect', 'area', 'facet') for which sub-segments are being calculated.\n        symmetry_mode: The symmetry mode ('symmetric' or 'asymmetric') affecting segment calculation.\n        elements: A list of CompetenceElement instances at the current level.\n        lenient (bool): if True symmetry mode will be adjusted to count in case there are no values\n    Returns:\n        A dictionary where keys are element paths and values are DonutSegment instances representing each element's segment in the visualization.\n    \"\"\"\n    ringspec: RingSpec = ct.ring_specs[level_name]\n    sub_segments: Dict[str, DonutSegment] = {}\n    attr_names = {\"time\": \"time\", \"score\": \"max_score\"}\n    if len(elements) == 0:\n        return sub_segments\n    num_zero_none_values = 0\n\n    if symmetry_mode == \"count\":\n        total = len(elements)\n    else:\n        attr_name = attr_names[symmetry_mode]\n        total = 0\n        min_value = float(\n            \"inf\"\n        )  # Initialize to infinity for proper minimum comparison\n\n        # Initial loop to calculate total and count 0/None values\n        for element in elements:\n            value = getattr(element, attr_name)\n            if value in (0, None):\n                num_zero_none_values += 1\n            else:\n                total += value\n                if value &lt; min_value:\n                    min_value = value\n\n    if total == 0 and num_zero_none_values == len(elements):\n        if not lenient:\n            raise ValueError(\n                \"All element values are 0 or None, cannot divide segment.\"\n            )\n        else:\n            # robust reaction on issue\n            symmetry_mode = \"count\"\n            num_zero_none_values = 0\n            total = len(elements)\n\n    # Correct handling when all values are not 0/None\n    # and therefore  min_value was not updated\n    if num_zero_none_values &gt; 0:\n        # Adjust total value for 0/None values\n        # we use the min_value as a default\n        total += min_value * num_zero_none_values\n\n    start_angle = parent_segment.start_angle\n\n    for element in elements:\n        if symmetry_mode == \"count\":\n            value = 1\n        else:\n            value = getattr(element, attr_name) or min_value\n        proportion = value / total\n        angle_span = (\n            parent_segment.end_angle - parent_segment.start_angle\n        ) * proportion\n        end_angle = start_angle + angle_span\n\n        segment = self.create_donut_segment(\n            parent_segment, start_angle, end_angle, ringspec\n        )\n        sub_segments[element.path] = segment\n        start_angle = end_angle\n\n    return sub_segments\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.create_donut_segment","title":"<code>create_donut_segment(parent_segment, start_angle, end_angle, ringspec)</code>","text":"<p>Creates a new DonutSegment based on the specified parameters, calculating its inner and outer radii based on SVG configuration and ring specifications.</p> <p>Parameters:</p> Name Type Description Default <code>parent_segment</code> <code>DonutSegment</code> <p>The parent segment from which the new segment inherits its center (cx, cy).</p> required <code>start_angle</code> <code>float</code> <p>The starting angle of the new segment.</p> required <code>end_angle</code> <code>float</code> <p>The ending angle of the new segment.</p> required <code>ringspec</code> <code>RingSpec</code> <p>An instance of RingSpec defining the ratios for inner and outer radii, and the text mode.</p> required <p>Returns:</p> Name Type Description <code>DonutSegment</code> <code>DonutSegment</code> <p>A new DonutSegment instance configured as specified.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def create_donut_segment(\n    self,\n    parent_segment: DonutSegment,\n    start_angle: float,\n    end_angle: float,\n    ringspec: RingSpec,\n) -&gt; DonutSegment:\n    \"\"\"\n    Creates a new DonutSegment based on the specified parameters, calculating its\n    inner and outer radii based on SVG configuration and ring specifications.\n\n    Args:\n        parent_segment (DonutSegment): The parent segment from which the new segment inherits its center (cx, cy).\n        start_angle (float): The starting angle of the new segment.\n        end_angle (float): The ending angle of the new segment.\n        ringspec (RingSpec): An instance of RingSpec defining the ratios for inner and outer radii, and the text mode.\n\n    Returns:\n        DonutSegment: A new DonutSegment instance configured as specified.\n    \"\"\"\n    # Calculate the actual inner and outer radii based on the SVG config and ringspec ratios\n    inner_radius = self.svg.config.width / 2 * ringspec.inner_ratio\n    outer_radius = self.svg.config.width / 2 * ringspec.outer_ratio\n    # Create a new segment for this element\n    segment = DonutSegment(\n        cx=parent_segment.cx,\n        cy=parent_segment.cy,\n        inner_radius=inner_radius,\n        outer_radius=outer_radius,\n        start_angle=start_angle,\n        end_angle=end_angle,\n        text_mode=ringspec.text_mode,\n    )\n    return segment\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.generate_donut_segment_for_achievement","title":"<code>generate_donut_segment_for_achievement(svg, learner, element, segment)</code>","text":"<p>generate a donut segment for the learner's achievements corresponding to the given path and return it's segment definition</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def generate_donut_segment_for_achievement(\n    self,\n    svg: SVG,\n    learner: Learner,\n    element: CompetenceElement,\n    segment: DonutSegment,\n) -&gt; DonutSegment:\n    \"\"\"\n    generate a donut segment for the\n    learner's achievements\n    corresponding to the given path and return it's segment definition\n    \"\"\"\n    achievement = learner.achievements_by_path.get(element.path, None)\n    result = None\n    if achievement and achievement.level:\n        # Retrieve the color for the achievement level\n        level_color = self.dcm.competence_tree.get_level_color(achievement.level)\n\n        if level_color:\n            # set the color and radius of\n            # the segment for achievement\n            # make sure we don't interfere with the segment calculations\n            segment = copy.deepcopy(segment)\n            result = self.add_donut_segment(\n                svg, element, segment, level_color, achievement.level\n            )\n    return result\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.generate_donut_segment_for_element","title":"<code>generate_donut_segment_for_element(svg, element, learner, segment, ringspec=None)</code>","text":"<p>generate a donut segment for a given element of the CompetenceTree</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def generate_donut_segment_for_element(\n    self,\n    svg: SVG,\n    element: CompetenceElement,\n    learner: Learner,\n    segment: DonutSegment,\n    ringspec: RingSpec = None,\n) -&gt; DonutSegment:\n    \"\"\"\n    generate a donut segment for a given element of\n    the CompetenceTree\n    \"\"\"\n    if segment.outer_radius == 0.0:\n        result = segment\n    else:\n        # Simply create the donut segment without considering the achievement\n        result = self.add_donut_segment(\n            svg=svg, element=element, segment=segment, ringspec=ringspec\n        )\n        # check learner achievements\n        if learner:\n            _learner_segment = self.generate_donut_segment_for_achievement(\n                svg=svg, learner=learner, element=element, segment=segment\n            )\n    return result\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.generate_pie_elements_for_segments","title":"<code>generate_pie_elements_for_segments(svg, ct, segments, learner)</code>","text":"<p>Generate pie elements for the competence tree using pre-calculated segments.</p> <p>This method will iterate through the provided segments dictionary, using each pre-calculated DonutSegment to generate and render pie elements (e.g., aspects, areas, or facets) based on the learner's achievements.</p> <p>Parameters:</p> Name Type Description Default <code>svg</code> <code>SVG</code> <p>The SVG object where the pie elements will be drawn.</p> required <code>ct</code> <code>CompetenceTree</code> <p>The competence tree structure.</p> required <code>segments</code> <code>Dict[str, Dict[str, DonutSegment]]</code> <p>A nested dictionary where the first key is the                                            level name (e.g., 'aspect', 'area', 'facet'),                                            and the second key is an element's path, mapping                                            to its corresponding DonutSegment.</p> required <code>learner</code> <code>Learner</code> <p>The learner object containing achievement data.</p> required Source code in <code>dcm/dcm_chart.py</code> <pre><code>def generate_pie_elements_for_segments(\n    self,\n    svg: SVG,\n    ct: CompetenceTree,\n    segments: Dict[str, Dict[str, DonutSegment]],\n    learner: Learner,\n):\n    \"\"\"\n    Generate pie elements for the competence tree using pre-calculated segments.\n\n    This method will iterate through the provided segments dictionary, using each pre-calculated\n    DonutSegment to generate and render pie elements (e.g., aspects, areas, or facets) based on\n    the learner's achievements.\n\n    Args:\n        svg (SVG): The SVG object where the pie elements will be drawn.\n        ct (CompetenceTree): The competence tree structure.\n        segments (Dict[str, Dict[str, DonutSegment]]): A nested dictionary where the first key is the\n                                                       level name (e.g., 'aspect', 'area', 'facet'),\n                                                       and the second key is an element's path, mapping\n                                                       to its corresponding DonutSegment.\n        learner (Learner): The learner object containing achievement data.\n    \"\"\"\n    for level_name, segment_dict in segments.items():\n        ringspec = ct.ring_specs[level_name]\n        for path, segment in segment_dict.items():\n            element = ct.elements_by_path.get(path, None)\n            if element:\n                self.generate_donut_segment_for_element(\n                    svg, element, learner, segment=segment, ringspec=ringspec\n                )\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.generate_svg","title":"<code>generate_svg(filename=None, learner=None, config=None, text_mode='empty')</code>","text":"<p>Generate the SVG markup and optionally save it to a file. If a filename is given, the method will also save the SVG to that file. The SVG is generated based on internal state not shown here.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the SVG should be saved. Defaults to None.</p> <code>None</code> <code>learner(Learner)</code> <p>the learner to show the achievements for</p> required <code>config</code> <code>SVGConfig</code> <p>The configuration for the SVG canvas and legend. Defaults to default values.</p> <code>None</code> <code>text_mode(str)</code> <p>text display mode</p> required <p>Returns:     str: The SVG markup.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def generate_svg(\n    self,\n    filename: Optional[str] = None,\n    learner: Optional[Learner] = None,\n    config: Optional[SVGConfig] = None,\n    text_mode: str = \"empty\",\n) -&gt; str:\n    \"\"\"\n    Generate the SVG markup and optionally save it to a file. If a filename is given, the method\n    will also save the SVG to that file. The SVG is generated based on internal state not shown here.\n\n    Args:\n        filename (str, optional): The path to the file where the SVG should be saved. Defaults to None.\n        learner(Learner): the learner to show the achievements for\n        config (SVGConfig, optional): The configuration for the SVG canvas and legend. Defaults to default values.\n        text_mode(str): text display mode\n    Returns:\n        str: The SVG markup.\n    \"\"\"\n    if config is None:\n        config = SVGConfig(\n            with_popup=True\n        )  # Use default configuration if none provided\n    svg_markup = self.generate_svg_markup(\n        self.dcm.competence_tree,\n        learner=learner,\n        config=config,\n        text_mode=text_mode,\n    )\n    if filename:\n        self.save_svg_to_file(svg_markup, filename)\n    return svg_markup\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.generate_svg_markup","title":"<code>generate_svg_markup(competence_tree=None, learner=None, selected_paths=[], config=None, with_java_script=True, text_mode='empty', lookup_url='')</code>","text":"<p>Generate the SVG markup for the given CompetenceTree and Learner. This method creates an SVG representation of the competence map, which visualizes the structure and levels of competencies, along with highlighting the learner's achievements if provided.</p> <p>Parameters:</p> Name Type Description Default <code>competence_tree</code> <code>CompetenceTree</code> <p>The competence tree structure to be visualized. If None, the competence tree of the DcmChart instance will be used. Defaults to None.</p> <code>None</code> <code>learner</code> <code>Learner</code> <p>The learner whose achievements are to be visualized on the competence tree. If None, no learner-specific information will be included in the SVG. Defaults to None.</p> <code>None</code> <code>selected_paths</code> <code>List</code> <p>A list of paths that should be highlighted in the SVG. These paths typically represent specific competencies or achievements. Defaults to an empty list.</p> <code>[]</code> <code>config</code> <code>SVGConfig</code> <p>Configuration for the SVG canvas and legend. If None, default configuration settings are used. Defaults to None.</p> <code>None</code> <code>text_mode(str)</code> <p>text display mode</p> required <code>with_java_script</code> <code>bool</code> <p>Indicates whether to include JavaScript in the SVG for interactivity. Defaults to True.</p> <code>True</code> <code>lookup_url</code> <code>str</code> <p>Base URL for linking to detailed descriptions or information about the competence elements. If not provided, links will not be generated. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the SVG markup for the competence map.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are inconsistencies or issues with the provided data that prevent the creation of a valid SVG.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def generate_svg_markup(\n    self,\n    competence_tree: CompetenceTree = None,\n    learner: Learner = None,\n    selected_paths: List = [],\n    config: SVGConfig = None,\n    with_java_script: bool = True,\n    text_mode: str = \"empty\",\n    lookup_url: str = \"\",\n) -&gt; str:\n    \"\"\"\n    Generate the SVG markup for the given CompetenceTree and Learner. This method\n    creates an SVG representation of the competence map, which visualizes the\n    structure and levels of competencies, along with highlighting the learner's\n    achievements if provided.\n\n    Args:\n        competence_tree (CompetenceTree, optional): The competence tree structure\n            to be visualized. If None, the competence tree of the DcmChart instance\n            will be used. Defaults to None.\n        learner (Learner, optional): The learner whose achievements are to be\n            visualized on the competence tree. If None, no learner-specific\n            information will be included in the SVG. Defaults to None.\n        selected_paths (List, optional): A list of paths that should be highlighted\n            in the SVG. These paths typically represent specific competencies or\n            achievements. Defaults to an empty list.\n        config (SVGConfig, optional): Configuration for the SVG canvas and legend.\n            If None, default configuration settings are used. Defaults to None.\n        text_mode(str): text display mode\n        with_java_script (bool, optional): Indicates whether to include JavaScript\n            in the SVG for interactivity. Defaults to True.\n        lookup_url (str, optional): Base URL for linking to detailed descriptions\n            or information about the competence elements. If not provided, links\n            will not be generated. Defaults to an empty string.\n\n    Returns:\n        str: A string containing the SVG markup for the competence map.\n\n    Raises:\n        ValueError: If there are inconsistencies or issues with the provided data\n            that prevent the creation of a valid SVG.\n    \"\"\"\n    if competence_tree is None:\n        competence_tree = self.dcm.competence_tree\n    self.selected_paths = selected_paths\n\n    competence_tree.calculate_ring_specs(text_mode)\n    svg = self.prepare_and_add_inner_circle(config, competence_tree, lookup_url)\n\n    segment = DonutSegment(\n        cx=self.cx, cy=self.cy, inner_radius=0, outer_radius=self.tree_radius\n    )\n    segments = self.calculate_segments(competence_tree, segment)\n    self.generate_pie_elements_for_segments(\n        svg=svg, ct=competence_tree, segments=segments, learner=learner\n    )\n    # self.generate_pie_elements(\n    #    level=1,\n    #    svg=svg,\n    #    ct=competence_tree,\n    #    parent_element=competence_tree,\n    #    learner=learner,\n    #    segment=segment,\n    # )\n    if svg.config.legend_height &gt; 0:\n        competence_tree.add_legend(svg)\n\n    return svg.get_svg_markup(with_java_script=with_java_script)\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.get_element_config","title":"<code>get_element_config(element)</code>","text":"<p>get a configuration for the given element</p> <p>Parameters:</p> Name Type Description Default <code>element(CompetenceElement)</code> <p>the element</p> required Return <p>SVGNodeConfig: an SVG Node configuration</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def get_element_config(self, element: CompetenceElement) -&gt; SVGNodeConfig:\n    \"\"\"\n    get a configuration for the given element\n\n    Args:\n        element(CompetenceElement): the element\n\n    Return:\n        SVGNodeConfig: an SVG Node configuration\n    \"\"\"\n    if element is None:\n        element_config = SVGNodeConfig(x=self.cx, y=self.cy, fill=\"white\")\n        return element_config\n    element_url = (\n        element.url\n        if element.url\n        else (\n            f\"{self.lookup_url}/description/{element.path}\"\n            if self.lookup_url is not None\n            else None\n        )\n    )\n    show_as_popup = element.url is None\n    element_config = element.to_svg_node_config(\n        url=element_url,\n        show_as_popup=show_as_popup,\n        x=self.cx,\n        y=self.cy,\n    )\n    return element_config\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.get_stacked_segment","title":"<code>get_stacked_segment(level, total_levels, segment, element_config)</code>","text":"<p>Calculate the stacked segment for a given level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The current level for which to calculate the segment.</p> required <code>total_levels</code> <code>int</code> <p>The total number of levels.</p> required <code>segment</code> <code>DonutSegment</code> <p>The original donut Segment.</p> required <code>element_config</code> <code>SVGNodeConfig</code> <p>The element configuration.</p> required <p>Returns:</p> Type Description <code>Tuple[DonutSegment, SVGNodeConfig]</code> <p>Tuple[DonutSegment, SVGNodeConfig]: The calculated stacked segment and its configuration for the given level.</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def get_stacked_segment(\n    self,\n    level: int,\n    total_levels: int,\n    segment: DonutSegment,\n    element_config: SVGNodeConfig,\n) -&gt; Tuple[DonutSegment, SVGNodeConfig]:\n    \"\"\"\n    Calculate the stacked segment for a given level.\n\n    Args:\n        level (int): The current level for which to calculate the segment.\n        total_levels (int): The total number of levels.\n        segment (DonutSegment): The original donut Segment.\n        element_config (SVGNodeConfig): The element configuration.\n\n    Returns:\n        Tuple[DonutSegment, SVGNodeConfig]:\n            The calculated stacked segment and its configuration for the given level.\n\n    \"\"\"\n    level_color = self.dcm.competence_tree.get_level_color(level)\n    stack_element_config = copy.deepcopy(element_config)\n    stack_element_config.fill = level_color\n    ratio = level / total_levels\n    relative_radius = (segment.outer_radius - segment.inner_radius) * ratio\n    stacked_segment = copy.deepcopy(segment)\n    stacked_segment.outer_radius = segment.inner_radius + relative_radius\n    return stacked_segment, stack_element_config\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.prepare_and_add_inner_circle","title":"<code>prepare_and_add_inner_circle(config, competence_tree, lookup_url=None)</code>","text":"<p>prepare the SVG markup generation and add the inner_circle</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def prepare_and_add_inner_circle(\n    self, config, competence_tree: CompetenceTree, lookup_url: str = None\n):\n    \"\"\"\n    prepare the SVG markup generation and add\n    the inner_circle\n    \"\"\"\n    self.lookup_url = (\n        competence_tree.lookup_url if competence_tree.lookup_url else lookup_url\n    )\n\n    svg = SVG(config)\n    self.svg = svg\n    config = svg.config\n    # center of circle\n    self.cx = config.width // 2\n    self.cy = (config.total_height - config.legend_height) // 2\n    ringspec = competence_tree.ring_specs.get(\"tree\")\n    self.tree_radius = ringspec.outer_ratio * config.width / 2\n\n    self.circle_config = competence_tree.to_svg_node_config(\n        x=self.cx, y=self.cy, width=self.tree_radius\n    )\n    svg.add_circle(config=self.circle_config)\n    if ringspec.text_mode != \"empty\":\n        svg.add_text(\n            self.cx,\n            self.cy,\n            competence_tree.short_name,\n            text_anchor=\"middle\",\n            center_v=True,\n            fill=\"white\",\n        )\n    return svg\n</code></pre>"},{"location":"#dcm.dcm_chart.DcmChart.save_svg_to_file","title":"<code>save_svg_to_file(svg_markup, filename)</code>","text":"<p>Save the SVG content to a file</p> Source code in <code>dcm/dcm_chart.py</code> <pre><code>def save_svg_to_file(self, svg_markup: str, filename: str):\n    \"\"\"\n    Save the SVG content to a file\n    \"\"\"\n    with open(filename, \"w\") as file:\n        file.write(svg_markup)\n</code></pre>"},{"location":"#dcm.dcm_cmd","title":"<code>dcm_cmd</code>","text":"<p>Created on 2023-11-06</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_cmd.CompetenceCmd","title":"<code>CompetenceCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command line for diagrams server</p> Source code in <code>dcm/dcm_cmd.py</code> <pre><code>class CompetenceCmd(WebserverCmd):\n    \"\"\"\n    Command line for diagrams server\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=DynamicCompetenceMap.examples_path(),\n            help=\"path to example dcm definition files [default: %(default)s]\",\n        )\n        return parser\n</code></pre>"},{"location":"#dcm.dcm_cmd.CompetenceCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>dcm/dcm_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=DynamicCompetenceMap.examples_path(),\n        help=\"path to example dcm definition files [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#dcm.dcm_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>dcm/dcm_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = CompetenceCmd(\n        config=DynamicCompentenceMapWebServer.get_config(),\n        webserver_cls=DynamicCompentenceMapWebServer,\n    )\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#dcm.dcm_core","title":"<code>dcm_core</code>","text":"<p>Created on 2023-06-11</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_core.Achievement","title":"<code>Achievement</code>  <code>dataclass</code>","text":"<p>Class representing an individual's achievement level for a specific competence facet.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>The path in the CompetenceTree, used to derive tree_id, aspect_id, and facet_id.</p> <code>level</code> <code>int</code> <p>The achieved level for this facet.</p> <code>score</code> <code>float</code> <p>How well the achievement was reached.</p> <code>score_unit</code> <code>str</code> <p>Unit of the score, default is \"%\".</p> <code>evidence</code> <code>Optional[str]</code> <p>Optional evidence supporting the achievement.</p> <code>date_assessed</code> <code>Optional[str]</code> <p>Optional date when the achievement was assessed (ISO-Format).</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass Achievement:\n    \"\"\"\n    Class representing an individual's achievement level for a specific competence facet.\n\n    Attributes:\n        path (str): The path in the CompetenceTree, used to derive tree_id, aspect_id, and facet_id.\n        level (int): The achieved level for this facet.\n        score (float): How well the achievement was reached.\n        score_unit (str): Unit of the score, default is \"%\".\n        evidence (Optional[str]): Optional evidence supporting the achievement.\n        date_assessed (Optional[str]): Optional date when the achievement was assessed (ISO-Format).\n    \"\"\"\n\n    path: str\n    level: Optional[int] = None\n    score: Optional[float] = None\n    score_unit: Optional[str] = \"%\"\n    evidence: Optional[str] = None\n    date_assessed_iso: Optional[str] = None\n\n    @property\n    def tree_id(self):\n        parts = self.path.split(\"/\")\n        return parts[0] if parts else None\n\n    @property\n    def aspect_id(self):\n        parts = self.path.split(\"/\")\n        return parts[1] if len(parts) &gt; 1 else None\n\n    @property\n    def area_id(self):\n        parts = self.path.split(\"/\")\n        return parts[2] if len(parts) &gt; 2 else None\n\n    @property\n    def facet_id(self):\n        parts = self.path.split(\"/\")\n        return parts[3] if len(parts) &gt; 3 else None\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceArea","title":"<code>CompetenceArea</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CompetenceElement</code></p> <p>Represents a specific area within a competence aspect, containing various facets.</p> <p>Attributes:</p> Name Type Description <code>facets</code> <code>List[CompetenceFacet]</code> <p>A list of CompetenceFacet objects representing individual facets of this area.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceArea(CompetenceElement):\n    \"\"\"\n    Represents a specific area within a competence aspect, containing various facets.\n\n    Attributes:\n        facets (List[CompetenceFacet]): A list of CompetenceFacet objects representing individual facets of this area.\n    \"\"\"\n\n    facets: List[CompetenceFacet] = field(default_factory=list)\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceAspect","title":"<code>CompetenceAspect</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CompetenceElement</code></p> <p>Represents a broader category of competence, which includes various areas.</p> <p>Attributes:</p> Name Type Description <code>areas</code> <code>List[CompetenceArea]</code> <p>A list of CompetenceArea objects representing individual areas of this aspect.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceAspect(CompetenceElement):\n    \"\"\"\n    Represents a broader category of competence, which includes various areas.\n\n    Attributes:\n        areas (List[CompetenceArea]): A list of CompetenceArea objects representing individual areas of this aspect.\n    \"\"\"\n\n    areas: List[CompetenceArea] = field(default_factory=list)\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceElement","title":"<code>CompetenceElement</code>  <code>dataclass</code>","text":"<p>A base class representing a generic competence element with common properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the competence element.</p> <code>short_name(Optional[str])</code> <code>str</code> <p>the label to be displayed</p> <code>id</code> <code>Optional[str]</code> <p>An optional identifier for the competence element will be set to the name if id is None.</p> <code>url</code> <code>Optional[str]</code> <p>An optional URL for more information about the competence element.</p> <code>description</code> <code>Optional[str]</code> <p>An optional description of the competence element.</p> <code>color_code</code> <code>str</code> <p>A string representing a (fill) color code associated with the competence element.</p> <code>border_color</code> <code>str</code> <p>A string representing the border color to be used e.g. \"black\" or \"#ffffff\"</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceElement:\n    \"\"\"\n    A base class representing a generic competence element with common properties.\n\n    Attributes:\n        name (str): The name of the competence element.\n        short_name(Optional[str]): the label to be displayed\n        id (Optional[str]): An optional identifier for the competence element will be set to the name if id is None.\n        url (Optional[str]): An optional URL for more information about the competence element.\n        description (Optional[str]): An optional description of the competence element.\n        color_code (str): A string representing a (fill) color code associated with the competence element.\n        border_color (str): A string representing the border color to be used e.g. \"black\" or \"#ffffff\"\n    \"\"\"\n\n    name: str\n    short_name: Optional[str] = None\n    id: Optional[str] = None\n    url: Optional[str] = None\n    description: Optional[str] = None\n    color_code: Optional[str] = None\n    border_color: Optional[str] = None\n\n    time: Optional[float] = None\n    time_unit: Optional[str] = None  # h/CP\n    max_score: Optional[float] = None  # 100\n    score_unit: Optional[str] = None  # %\n\n    def __post_init__(self):\n        # Set the id to the the slug of the name if id is None\n        if self.id is None:\n            # https://pypi.org/project/python-slugify/\n            self.id = slugify(self.name, lowercase=False, regex_pattern=r\"[^\\w\\-]\")\n        if self.short_name is None:\n            self.short_name = self.name[:10]\n\n    def as_html(self) -&gt; str:\n        \"\"\"\n        convert me to html\n\n        Returns:\n            str: html markup\n        \"\"\"\n        html = f\"&lt;h2&gt;{self.name}&lt;/h2&gt;\"\n        if self.description:\n            desc_html = markdown2.markdown(\n                self.description, extras=[\"fenced-code-blocks\", \"tables\", \"spoiler\"]\n            )\n            html = html + \"\\n\" + desc_html\n        return html\n\n    def to_svg_node_config(self, url: str = None, **kwargs) -&gt; SVGNodeConfig:\n        \"\"\"\n        convert me to an SVGNode Configuration\n\n        Args:\n            url(str): the url to use for clicking this svg node - if None use\n            my configured url\n        \"\"\"\n        if url is None:\n            url = self.url\n        element_type = f\"{self.__class__.__name__}\"\n        comment = f\"{element_type}:{self.description}\"\n        svg_node_config = SVGNodeConfig(\n            element_type=f\"{element_type}\",\n            id=f\"{self.id}\",\n            url=url,\n            fill=self.color_code,\n            color=self.border_color,\n            title=self.name,\n            comment=comment,\n            **kwargs,\n        )\n        return svg_node_config\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceElement.as_html","title":"<code>as_html()</code>","text":"<p>convert me to html</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>html markup</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def as_html(self) -&gt; str:\n    \"\"\"\n    convert me to html\n\n    Returns:\n        str: html markup\n    \"\"\"\n    html = f\"&lt;h2&gt;{self.name}&lt;/h2&gt;\"\n    if self.description:\n        desc_html = markdown2.markdown(\n            self.description, extras=[\"fenced-code-blocks\", \"tables\", \"spoiler\"]\n        )\n        html = html + \"\\n\" + desc_html\n    return html\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceElement.to_svg_node_config","title":"<code>to_svg_node_config(url=None, **kwargs)</code>","text":"<p>convert me to an SVGNode Configuration</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to use for clicking this svg node - if None use</p> required Source code in <code>dcm/dcm_core.py</code> <pre><code>def to_svg_node_config(self, url: str = None, **kwargs) -&gt; SVGNodeConfig:\n    \"\"\"\n    convert me to an SVGNode Configuration\n\n    Args:\n        url(str): the url to use for clicking this svg node - if None use\n        my configured url\n    \"\"\"\n    if url is None:\n        url = self.url\n    element_type = f\"{self.__class__.__name__}\"\n    comment = f\"{element_type}:{self.description}\"\n    svg_node_config = SVGNodeConfig(\n        element_type=f\"{element_type}\",\n        id=f\"{self.id}\",\n        url=url,\n        fill=self.color_code,\n        color=self.border_color,\n        title=self.name,\n        comment=comment,\n        **kwargs,\n    )\n    return svg_node_config\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceFacet","title":"<code>CompetenceFacet</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CompetenceElement</code></p> <p>Represents a specific facet of a competence aspect, inheriting from CompetenceElement.</p> <p>This class can include additional properties or methods specific to a competence facet.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceFacet(CompetenceElement):\n    \"\"\"\n    Represents a specific facet of a competence aspect, inheriting from CompetenceElement.\n\n    This class can include additional properties or methods specific to a competence facet.\n    \"\"\"\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceLevel","title":"<code>CompetenceLevel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CompetenceElement</code></p> <p>Defines a specific level of competence within the framework.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>int</code> <p>level number starting from 1 as the lowest and going up to as many level as defined for the CompetenceTree</p> <code>icon(str)</code> <code>int</code> <p>the name of a google mdi icon to be shown for this level</p> <code>utf8_icon(str)</code> <code>int</code> <p>utf-8 char string to be used as icon</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceLevel(CompetenceElement):\n    \"\"\"\n    Defines a specific level of competence within the framework.\n\n    Attributes:\n        level (int): level number starting from 1 as the lowest and going up to as many level as defined for the CompetenceTree\n        icon(str): the name of a google mdi icon to be shown for this level\n        utf8_icon(str): utf-8 char string to be used as icon\n    \"\"\"\n\n    level: int = 1\n    icon: Optional[str] = None\n    utf8_icon: Optional[str] = None\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree","title":"<code>CompetenceTree</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CompetenceElement</code>, <code>YamlAble['CompetenceTree']</code></p> <p>Represents the entire structure of competencies, including various aspects and levels.</p> <p>Attributes:</p> Name Type Description <code>lookup_url</code> <code>Optional[str]</code> <p>Optional URL for additional information.</p> <code>total_levels</code> <code>int</code> <p>Total number of levels in the competence hierarchy.</p> <code>stacked_levels</code> <code>Optional[bool]</code> <p>Indicates whether the levels are stacked.</p> <code>aspects</code> <code>List[CompetenceAspect]</code> <p>A list of CompetenceAspect objects.</p> <code>levels</code> <code>List[CompetenceLevel]</code> <p>A list of CompetenceLevel objects.</p> <code>element_names</code> <code>Dict[str, str]</code> <p>A dictionary holding the names for tree, aspects, facets, and levels.  The key is the type (\"tree\", \"aspect\", \"facet\", \"level\").</p> <code>ring_specs</code> <code>Dict[str, RingSpec]</code> <p>Specifications for the rings in the donut chart.</p> <code>total_elements</code> <code>Dict[str, int]</code> <p>A dictionary holding the total number of elements for each type (aspects, areas, facets).</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass CompetenceTree(CompetenceElement, YamlAble[\"CompetenceTree\"]):\n    \"\"\"\n    Represents the entire structure of competencies, including various aspects and levels.\n\n    Attributes:\n        lookup_url (Optional[str]): Optional URL for additional information.\n        total_levels (int): Total number of levels in the competence hierarchy.\n        stacked_levels (Optional[bool]): Indicates whether the levels are stacked.\n        aspects (List[CompetenceAspect]): A list of CompetenceAspect objects.\n        levels (List[CompetenceLevel]): A list of CompetenceLevel objects.\n        element_names (Dict[str, str]): A dictionary holding the names for tree, aspects, facets, and levels.  The key is the type (\"tree\", \"aspect\", \"facet\", \"level\").\n        ring_specs (Dict[str, RingSpec]): Specifications for the rings in the donut chart.\n        total_elements (Dict[str, int]): A dictionary holding the total number of elements for each type (aspects, areas, facets).\n    \"\"\"\n\n    lookup_url: Optional[str] = None\n    total_levels: int = field(init=False)\n    stacked_levels: Optional[bool] = False\n    aspects: List[CompetenceAspect] = field(default_factory=list)\n    levels: List[CompetenceLevel] = field(default_factory=list)\n    element_names: Dict[str, str] = field(default_factory=dict)\n    ring_specs: Dict[str, RingSpec] = field(default_factory=dict)\n    total_elements: Dict[str, int] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"\n        initalize the path variables of my hierarchy\n        \"\"\"\n        super().__post_init__()\n        self.update_paths()\n        self.calculate_ring_specs(\"empty\")\n\n    def calculate_ring_specs(self, text_mode: str):\n        \"\"\"\n        calculate the ring specifications\n        \"\"\"\n        inner_ratio = 0.0\n        circle_ratio = 1 / (self.total_levels * 2 + 1)\n        outer_ratio = circle_ratio\n        if not \"tree\" in self.ring_specs:\n            self.ring_specs[\"tree\"] = RingSpec(\n                text_mode=text_mode, inner_ratio=0.0, outer_ratio=circle_ratio\n            )\n        # loop over ring levels\n        for rl in [\"aspect\", \"area\", \"facet\"]:\n            inner_ratio = outer_ratio\n            outer_ratio = outer_ratio + circle_ratio * 2\n            if not rl in self.ring_specs:\n                self.ring_specs[rl] = RingSpec(\n                    text_mode=text_mode,\n                    inner_ratio=inner_ratio,\n                    outer_ratio=outer_ratio,\n                )\n\n    def set_symmetry_mode(self, symmetry_level: str, symmetry_mode: str):\n        \"\"\"\n         Sets a new symmetry mode for a specified level\n         in the competence tree. It resets the symmetry\n         mode for all levels to None and then\n         applies the new symmetry mode to the\n         specified level. This method ensures that\n         only one level has a symmetry mode set at any given time.\n\n        Args:\n            symmetry_level(str): The level to apply the new symmetry mode. Valid levels include \"tree\", \"aspect\", \"area\", and \"facet\".\n            symmetry_mode (str): The symmetry mode to set for the specified level. Valid modes are \"count\", \"score\", and \"time\".\n        \"\"\"\n        # reset all ring specs\n        for rl in [\"tree\", \"aspect\", \"area\", \"facet\"]:\n            self.ring_specs[rl].symmetry_mode = None\n        if symmetry_level in self.ring_specs:\n            self.ring_specs[symmetry_level].symmetry_mode = symmetry_mode\n\n    def get_symmetry_spec(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Get the symmetry specification from the ring_specs, ensuring only one spec has the symmetry mode set.\n\n        Returns:\n            Tuple[str, str]: A pair of symmetry mode and the level it is applied to.\n\n        Raises:\n            ValueError: If multiple RingSpecs have a symmetry mode set.\n        \"\"\"\n\n        symmetry_modes = [\n            (level, spec.symmetry_mode)\n            for level, spec in self.ring_specs.items()\n            if spec.symmetry_mode\n        ]\n        if len(symmetry_modes) &gt; 1:\n            raise ValueError(\"Symmetry mode set for multiple ring specs.\")\n        elif len(symmetry_modes) == 1:\n            level, mode = symmetry_modes[0]\n        else:\n            # Default to \"count\" and CompetenceFacet level if no spec is given\n            level, mode = (\"facet\", \"count\")\n        if not mode in [\"count\", \"score\", \"time\"]:\n            raise ValueError(\n                f\"Invalid symmetry mode {mode} - must be count, score or time\"\n            )\n        return (level, mode)\n\n    def get_elements_for_level(self, level: int) -&gt; List[CompetenceElement]:\n        \"\"\"\n        get the elements for the given hierarchy level\n\n        Args:\n            level(int): the hierarchy level\n\n        Returns:\n            List(CompetencElement): the list of elements on this level\n        \"\"\"\n        level_name = self.level_names[level]\n        elements = self.elements_by_level[level_name]\n        return elements\n\n    def update_paths(self):\n        \"\"\"\n        update my paths\n        \"\"\"\n        self.level_names = [\"tree\", \"aspect\", \"area\", \"facet\"]\n        self.level_attr_names = [None, \"aspects\", \"areas\", \"facets\"]\n        self.total_elements = {\"tree\": 1, \"aspects\": 0, \"areas\": 0, \"facets\": 0}\n        self.elements_by_level = {\n            \"tree\": [self],\n            \"aspect\": [],\n            \"area\": [],\n            \"facet\": [],\n        }  # Reset for re-calculation\n\n        self.path = self.id\n        self.total_levels = 1\n        self.elements_by_path = {self.path: self}\n        # Loop through each competence aspect and set their paths and parent references\n        for aspect in self.aspects:\n            aspect.competence_tree = self\n            aspect.path = f\"{self.id}/{aspect.id}\"\n            self.elements_by_path[aspect.path] = aspect\n            self.total_elements[\"aspects\"] = self.total_elements[\"aspects\"] + 1\n            self.total_levels = 2\n            self.elements_by_level[\"aspect\"].append(aspect)\n            for area in aspect.areas:\n                self.total_levels = 3\n                area.competence_tree = self\n                area.aspect = aspect\n                area.path = f\"{self.id}/{aspect.id}/{area.id}\"\n                self.elements_by_path[area.path] = area\n                self.total_elements[\"areas\"] = self.total_elements[\"areas\"] + 1\n                self.elements_by_level[\"area\"].append(area)\n                for facet in area.facets:\n                    self.total_levels = 4\n                    facet.competence_tree = self\n                    facet.area = area\n                    facet.path = f\"{self.id}/{aspect.id}/{area.id}/{facet.id}\"\n                    self.elements_by_path[facet.path] = facet\n                    self.total_elements[\"facets\"] = self.total_elements[\"facets\"] + 1\n                    self.elements_by_level[\"facet\"].append(facet)\n\n    @classmethod\n    def required_keys(cls) -&gt; Tuple:\n        keys = {\"name\", \"id\", \"url\", \"description\", \"aspects\"}\n        return keys\n\n    def lookup_by_path(\n        self, path: str, lenient: bool = True\n    ) -&gt; Optional[CompetenceElement]:\n        \"\"\"\n        Look up and return a competence element (tree,aspect of facet)\n        based on the given path.\n\n        The path is expected to be in the format \"tree_id/aspect_id/facet_id\".\n        This method parses the path and retrieves the corresponding competence aspect or facet.\n\n        Args:\n            path (str): The path in the format \"tree_id/aspect_id/facet_id\".\n\n            lenient(bool): if not lenient raise Exceptions for invalid paths and ids\n        Returns:\n            Optional[CompetenceElement]: The competence aspect or facet corresponding to the given path.\n        \"\"\"\n\n        def handle_error(msg):\n            if not lenient:\n                raise ValueError(msg)\n\n        element = None\n        if path not in self.elements_by_path:\n            msg = f\"invalid path {path}\"\n            if not lenient:\n                raise ValueError(msg)\n        else:\n            element = self.elements_by_path.get(path)\n        return element\n\n    @property\n    def total_valid_levels(self) -&gt; int:\n        \"\"\"\n        Calculate the total number of levels excluding\n        levels with a level of 0.\n\n        Returns:\n            int: The total number of valid levels.\n        \"\"\"\n        level_count = len([level for level in self.levels if level.level != 0])\n        return level_count\n\n    def get_level_color(self, achievement_level: int) -&gt; Optional[str]:\n        \"\"\"\n        Retrieve the color associated with a specific achievement level.\n\n        Args:\n            achievement_level (int): The level of achievement to get the color for.\n\n        Returns:\n            Optional[str]: The color code associated with the given level, or None if not found.\n        \"\"\"\n        for level in self.levels:\n            if level.level == achievement_level:\n                return level.color_code\n        return None\n\n    def to_pretty_json(self):\n        \"\"\"\n        Converts the CompetenceTree object to a pretty JSON string, handling null values.\n        \"\"\"\n        json_str = self.to_json()\n        json_dict = json.loads(json_str)\n\n        def remove_none_values(data):\n            \"\"\"\n            Recursively removes keys with None values from a dictionary, list, or nested structure.\n            \"\"\"\n            if isinstance(data, dict):\n                return {\n                    k: remove_none_values(v) for k, v in data.items() if v is not None\n                }\n            elif isinstance(data, list):\n                return [remove_none_values(item) for item in data]\n            return data\n\n        none_free_dict = remove_none_values(json_dict)\n        null_free_json_str = json.dumps(none_free_dict, indent=2)\n        return null_free_json_str\n\n    def add_legend(self, svg: SVG) -&gt; None:\n        \"\"\"\n        Add a legend to the SVG explaining the color codes for levels and aspects.\n        Args:\n            svg (SVG): The SVG object to which the legend will be added.\n        \"\"\"\n        # Starting x position for the legends, starting 10 pixels from the left edge\n        x_start = 10\n        # y position for the legends, starting 20 pixels from the bottom edge\n        y = svg.config.total_height - svg.config.legend_height + 20\n        # Width and height of each legend color box\n        box_width, box_height = 30, 20\n        # Padding between legend items and between the color box and the text\n        padding = 5\n\n        # Add the competence level legend\n        level_items = [(level.color_code, level.name) for level in self.levels]\n        svg.add_legend_column(\n            level_items,\n            self.element_names.get(\"level\", \"Level\"),\n            x_start,\n            y,\n            box_width,\n            box_height,\n        )\n        max_name_width = 5\n        if self.levels:\n            max_name_width = max(\n                svg.get_text_width(level.name) for level in self.levels\n            )\n        # Calculate the x position for the aspect legend based on the width of the level legend\n        x_aspect_start = x_start + box_width + padding + max_name_width + padding\n\n        # Add the competence aspect legend\n        aspect_items = [(aspect.color_code, aspect.name) for aspect in self.aspects]\n        svg.add_legend_column(\n            aspect_items,\n            self.element_names.get(\"aspect\", \"Aspect\"),\n            x_aspect_start,\n            y,\n            box_width,\n            box_height,\n        )\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.total_valid_levels","title":"<code>total_valid_levels: int</code>  <code>property</code>","text":"<p>Calculate the total number of levels excluding levels with a level of 0.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The total number of valid levels.</p>"},{"location":"#dcm.dcm_core.CompetenceTree.__post_init__","title":"<code>__post_init__()</code>","text":"<p>initalize the path variables of my hierarchy</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    initalize the path variables of my hierarchy\n    \"\"\"\n    super().__post_init__()\n    self.update_paths()\n    self.calculate_ring_specs(\"empty\")\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.add_legend","title":"<code>add_legend(svg)</code>","text":"<p>Add a legend to the SVG explaining the color codes for levels and aspects. Args:     svg (SVG): The SVG object to which the legend will be added.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def add_legend(self, svg: SVG) -&gt; None:\n    \"\"\"\n    Add a legend to the SVG explaining the color codes for levels and aspects.\n    Args:\n        svg (SVG): The SVG object to which the legend will be added.\n    \"\"\"\n    # Starting x position for the legends, starting 10 pixels from the left edge\n    x_start = 10\n    # y position for the legends, starting 20 pixels from the bottom edge\n    y = svg.config.total_height - svg.config.legend_height + 20\n    # Width and height of each legend color box\n    box_width, box_height = 30, 20\n    # Padding between legend items and between the color box and the text\n    padding = 5\n\n    # Add the competence level legend\n    level_items = [(level.color_code, level.name) for level in self.levels]\n    svg.add_legend_column(\n        level_items,\n        self.element_names.get(\"level\", \"Level\"),\n        x_start,\n        y,\n        box_width,\n        box_height,\n    )\n    max_name_width = 5\n    if self.levels:\n        max_name_width = max(\n            svg.get_text_width(level.name) for level in self.levels\n        )\n    # Calculate the x position for the aspect legend based on the width of the level legend\n    x_aspect_start = x_start + box_width + padding + max_name_width + padding\n\n    # Add the competence aspect legend\n    aspect_items = [(aspect.color_code, aspect.name) for aspect in self.aspects]\n    svg.add_legend_column(\n        aspect_items,\n        self.element_names.get(\"aspect\", \"Aspect\"),\n        x_aspect_start,\n        y,\n        box_width,\n        box_height,\n    )\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.calculate_ring_specs","title":"<code>calculate_ring_specs(text_mode)</code>","text":"<p>calculate the ring specifications</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def calculate_ring_specs(self, text_mode: str):\n    \"\"\"\n    calculate the ring specifications\n    \"\"\"\n    inner_ratio = 0.0\n    circle_ratio = 1 / (self.total_levels * 2 + 1)\n    outer_ratio = circle_ratio\n    if not \"tree\" in self.ring_specs:\n        self.ring_specs[\"tree\"] = RingSpec(\n            text_mode=text_mode, inner_ratio=0.0, outer_ratio=circle_ratio\n        )\n    # loop over ring levels\n    for rl in [\"aspect\", \"area\", \"facet\"]:\n        inner_ratio = outer_ratio\n        outer_ratio = outer_ratio + circle_ratio * 2\n        if not rl in self.ring_specs:\n            self.ring_specs[rl] = RingSpec(\n                text_mode=text_mode,\n                inner_ratio=inner_ratio,\n                outer_ratio=outer_ratio,\n            )\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.get_elements_for_level","title":"<code>get_elements_for_level(level)</code>","text":"<p>get the elements for the given hierarchy level</p> <p>Parameters:</p> Name Type Description Default <code>level(int)</code> <p>the hierarchy level</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>CompetencElement</code> <p>the list of elements on this level</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def get_elements_for_level(self, level: int) -&gt; List[CompetenceElement]:\n    \"\"\"\n    get the elements for the given hierarchy level\n\n    Args:\n        level(int): the hierarchy level\n\n    Returns:\n        List(CompetencElement): the list of elements on this level\n    \"\"\"\n    level_name = self.level_names[level]\n    elements = self.elements_by_level[level_name]\n    return elements\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.get_level_color","title":"<code>get_level_color(achievement_level)</code>","text":"<p>Retrieve the color associated with a specific achievement level.</p> <p>Parameters:</p> Name Type Description Default <code>achievement_level</code> <code>int</code> <p>The level of achievement to get the color for.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The color code associated with the given level, or None if not found.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def get_level_color(self, achievement_level: int) -&gt; Optional[str]:\n    \"\"\"\n    Retrieve the color associated with a specific achievement level.\n\n    Args:\n        achievement_level (int): The level of achievement to get the color for.\n\n    Returns:\n        Optional[str]: The color code associated with the given level, or None if not found.\n    \"\"\"\n    for level in self.levels:\n        if level.level == achievement_level:\n            return level.color_code\n    return None\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.get_symmetry_spec","title":"<code>get_symmetry_spec()</code>","text":"<p>Get the symmetry specification from the ring_specs, ensuring only one spec has the symmetry mode set.</p> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: A pair of symmetry mode and the level it is applied to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If multiple RingSpecs have a symmetry mode set.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def get_symmetry_spec(self) -&gt; Tuple[str, str]:\n    \"\"\"\n    Get the symmetry specification from the ring_specs, ensuring only one spec has the symmetry mode set.\n\n    Returns:\n        Tuple[str, str]: A pair of symmetry mode and the level it is applied to.\n\n    Raises:\n        ValueError: If multiple RingSpecs have a symmetry mode set.\n    \"\"\"\n\n    symmetry_modes = [\n        (level, spec.symmetry_mode)\n        for level, spec in self.ring_specs.items()\n        if spec.symmetry_mode\n    ]\n    if len(symmetry_modes) &gt; 1:\n        raise ValueError(\"Symmetry mode set for multiple ring specs.\")\n    elif len(symmetry_modes) == 1:\n        level, mode = symmetry_modes[0]\n    else:\n        # Default to \"count\" and CompetenceFacet level if no spec is given\n        level, mode = (\"facet\", \"count\")\n    if not mode in [\"count\", \"score\", \"time\"]:\n        raise ValueError(\n            f\"Invalid symmetry mode {mode} - must be count, score or time\"\n        )\n    return (level, mode)\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.lookup_by_path","title":"<code>lookup_by_path(path, lenient=True)</code>","text":"<p>Look up and return a competence element (tree,aspect of facet) based on the given path.</p> <p>The path is expected to be in the format \"tree_id/aspect_id/facet_id\". This method parses the path and retrieves the corresponding competence aspect or facet.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path in the format \"tree_id/aspect_id/facet_id\".</p> required <code>lenient(bool)</code> <p>if not lenient raise Exceptions for invalid paths and ids</p> required <p>Returns:     Optional[CompetenceElement]: The competence aspect or facet corresponding to the given path.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def lookup_by_path(\n    self, path: str, lenient: bool = True\n) -&gt; Optional[CompetenceElement]:\n    \"\"\"\n    Look up and return a competence element (tree,aspect of facet)\n    based on the given path.\n\n    The path is expected to be in the format \"tree_id/aspect_id/facet_id\".\n    This method parses the path and retrieves the corresponding competence aspect or facet.\n\n    Args:\n        path (str): The path in the format \"tree_id/aspect_id/facet_id\".\n\n        lenient(bool): if not lenient raise Exceptions for invalid paths and ids\n    Returns:\n        Optional[CompetenceElement]: The competence aspect or facet corresponding to the given path.\n    \"\"\"\n\n    def handle_error(msg):\n        if not lenient:\n            raise ValueError(msg)\n\n    element = None\n    if path not in self.elements_by_path:\n        msg = f\"invalid path {path}\"\n        if not lenient:\n            raise ValueError(msg)\n    else:\n        element = self.elements_by_path.get(path)\n    return element\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.set_symmetry_mode","title":"<code>set_symmetry_mode(symmetry_level, symmetry_mode)</code>","text":"<p>Sets a new symmetry mode for a specified level  in the competence tree. It resets the symmetry  mode for all levels to None and then  applies the new symmetry mode to the  specified level. This method ensures that  only one level has a symmetry mode set at any given time.</p> <p>Parameters:</p> Name Type Description Default <code>symmetry_level(str)</code> <p>The level to apply the new symmetry mode. Valid levels include \"tree\", \"aspect\", \"area\", and \"facet\".</p> required <code>symmetry_mode</code> <code>str</code> <p>The symmetry mode to set for the specified level. Valid modes are \"count\", \"score\", and \"time\".</p> required Source code in <code>dcm/dcm_core.py</code> <pre><code>def set_symmetry_mode(self, symmetry_level: str, symmetry_mode: str):\n    \"\"\"\n     Sets a new symmetry mode for a specified level\n     in the competence tree. It resets the symmetry\n     mode for all levels to None and then\n     applies the new symmetry mode to the\n     specified level. This method ensures that\n     only one level has a symmetry mode set at any given time.\n\n    Args:\n        symmetry_level(str): The level to apply the new symmetry mode. Valid levels include \"tree\", \"aspect\", \"area\", and \"facet\".\n        symmetry_mode (str): The symmetry mode to set for the specified level. Valid modes are \"count\", \"score\", and \"time\".\n    \"\"\"\n    # reset all ring specs\n    for rl in [\"tree\", \"aspect\", \"area\", \"facet\"]:\n        self.ring_specs[rl].symmetry_mode = None\n    if symmetry_level in self.ring_specs:\n        self.ring_specs[symmetry_level].symmetry_mode = symmetry_mode\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.to_pretty_json","title":"<code>to_pretty_json()</code>","text":"<p>Converts the CompetenceTree object to a pretty JSON string, handling null values.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def to_pretty_json(self):\n    \"\"\"\n    Converts the CompetenceTree object to a pretty JSON string, handling null values.\n    \"\"\"\n    json_str = self.to_json()\n    json_dict = json.loads(json_str)\n\n    def remove_none_values(data):\n        \"\"\"\n        Recursively removes keys with None values from a dictionary, list, or nested structure.\n        \"\"\"\n        if isinstance(data, dict):\n            return {\n                k: remove_none_values(v) for k, v in data.items() if v is not None\n            }\n        elif isinstance(data, list):\n            return [remove_none_values(item) for item in data]\n        return data\n\n    none_free_dict = remove_none_values(json_dict)\n    null_free_json_str = json.dumps(none_free_dict, indent=2)\n    return null_free_json_str\n</code></pre>"},{"location":"#dcm.dcm_core.CompetenceTree.update_paths","title":"<code>update_paths()</code>","text":"<p>update my paths</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def update_paths(self):\n    \"\"\"\n    update my paths\n    \"\"\"\n    self.level_names = [\"tree\", \"aspect\", \"area\", \"facet\"]\n    self.level_attr_names = [None, \"aspects\", \"areas\", \"facets\"]\n    self.total_elements = {\"tree\": 1, \"aspects\": 0, \"areas\": 0, \"facets\": 0}\n    self.elements_by_level = {\n        \"tree\": [self],\n        \"aspect\": [],\n        \"area\": [],\n        \"facet\": [],\n    }  # Reset for re-calculation\n\n    self.path = self.id\n    self.total_levels = 1\n    self.elements_by_path = {self.path: self}\n    # Loop through each competence aspect and set their paths and parent references\n    for aspect in self.aspects:\n        aspect.competence_tree = self\n        aspect.path = f\"{self.id}/{aspect.id}\"\n        self.elements_by_path[aspect.path] = aspect\n        self.total_elements[\"aspects\"] = self.total_elements[\"aspects\"] + 1\n        self.total_levels = 2\n        self.elements_by_level[\"aspect\"].append(aspect)\n        for area in aspect.areas:\n            self.total_levels = 3\n            area.competence_tree = self\n            area.aspect = aspect\n            area.path = f\"{self.id}/{aspect.id}/{area.id}\"\n            self.elements_by_path[area.path] = area\n            self.total_elements[\"areas\"] = self.total_elements[\"areas\"] + 1\n            self.elements_by_level[\"area\"].append(area)\n            for facet in area.facets:\n                self.total_levels = 4\n                facet.competence_tree = self\n                facet.area = area\n                facet.path = f\"{self.id}/{aspect.id}/{area.id}/{facet.id}\"\n                self.elements_by_path[facet.path] = facet\n                self.total_elements[\"facets\"] = self.total_elements[\"facets\"] + 1\n                self.elements_by_level[\"facet\"].append(facet)\n</code></pre>"},{"location":"#dcm.dcm_core.DynamicCompetenceMap","title":"<code>DynamicCompetenceMap</code>","text":"<p>a visualization of a competence map</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>class DynamicCompetenceMap:\n    \"\"\"\n    a visualization of a competence map\n    \"\"\"\n\n    def __init__(self, competence_tree: CompetenceTree, svg: SVG = None):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.competence_tree = competence_tree\n        self.svg = svg\n\n    @property\n    def main_id(self):\n        main_id = self.competence_tree.id\n        return main_id\n\n    @classmethod\n    def examples_path(cls) -&gt; str:\n        # the root directory (default: examples)\n        path = os.path.join(os.path.dirname(__file__), \"../dcm_examples\")\n        path = os.path.abspath(path)\n        return path\n\n    @classmethod\n    def get_example_dcm_definitions(\n        cls,\n        markup: str = \"json\",\n        required_keys: Optional[Tuple] = None,\n        as_text: bool = True,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieve example Dynamic Competence Map (DCM) definitions from files in the specified markup format (either JSON or YAML).\n\n        Args:\n            markup (str): The markup format of the input files. Defaults to 'json'. Supported values are 'json' and 'yaml'.\n            required_keys (Optional[Tuple]): A tuple of keys required to validate the data. If not provided, all keys will be considered valid.\n            as_text (bool): If True, returns the file content as text; if False, returns parsed data. Defaults to True.\n\n        Returns:\n            dict: A dictionary where each key is the prefix of the file name and the value is the file content as text or parsed data, depending on the value of 'as_text'.\n\n        Raises:\n            Exception: If there's an error in reading or parsing the file, or if the file does not meet the required validation criteria.\n        \"\"\"\n        example_dcm_defs = {}\n        file_ext = f\".{markup}\"\n        examples_path = cls.examples_path()\n        for dirpath, _dirnames, filenames in os.walk(examples_path):\n            for filename in filenames:\n                if filename.endswith(file_ext):\n                    filepath = os.path.join(dirpath, filename)\n                    with open(filepath, \"r\") as definition_file:\n                        file_prefix = filename.replace(file_ext, \"\")\n                        definition_text = definition_file.read()\n                        try:\n                            definition_data = cls.parse_markup(definition_text, markup)\n                            if cls.is_valid_definition(definition_data, required_keys):\n                                if as_text:\n                                    example_dcm_defs[file_prefix] = definition_text\n                                else:\n                                    example_dcm_defs[file_prefix] = definition_data\n                        except Exception as ex:\n                            cls.handle_markup_issue(\n                                filename, definition_text, ex, markup\n                            )\n        return example_dcm_defs\n\n    @classmethod\n    def parse_markup(cls, text: str, markup: str) -&gt; Union[dict, list]:\n        \"\"\"\n        Parse the given text as JSON or YAML based on the specified markup type.\n\n        Args:\n            text (str): The string content to be parsed.\n            markup (str): The type of markup to use for parsing. Supported values are 'json' and 'yaml'.\n\n        Returns:\n            Union[dict, list]: The parsed data, which can be either a dictionary or a list, depending on the content.\n\n        Raises:\n            ValueError: If an unsupported markup format is specified.\n        \"\"\"\n        if markup == \"json\":\n            data = json.loads(text)\n            return data\n        elif markup == \"yaml\":\n            data = yaml.safe_load(text)\n            return data\n        else:\n            raise ValueError(f\"Unsupported markup format: {markup}\")\n\n    @classmethod\n    def handle_markup_issue(cls, name: str, definition_string: str, ex, markup: str):\n        if isinstance(ex, JSONDecodeError):\n            lines = definition_string.splitlines()  # Split the string into lines\n            err_line = lines[ex.lineno - 1]  # JSONDecodeError gives 1-based lineno\n            pointer = (\n                \" \" * (ex.colno - 1) + \"^\"\n            )  # Create a pointer string to indicate the error position\n            error_message = (\n                f\"{name}:JSON parsing error on line {ex.lineno} column {ex.colno}:\\n\"\n                f\"{err_line}\\n\"\n                f\"{pointer}\\n\"\n                f\"{ex.msg}\"\n            )\n            raise ValueError(error_message)  # Raise a new exception with this message\n        else:\n            error_message = f\"error in {name}: {str(ex)}\"\n            raise ValueError(error_message)\n\n    @classmethod\n    def is_valid_definition(cls, definition_data, required_keys: Tuple):\n        return all(key in definition_data for key in required_keys)\n\n    @classmethod\n    def get_examples(cls, content_class=CompetenceTree, markup: str = \"json\") -&gt; dict:\n        examples = {}\n        for name, definition_string in cls.get_example_dcm_definitions(\n            required_keys=content_class.required_keys(), markup=markup\n        ).items():\n            example = cls.from_definition_string(\n                name, definition_string, content_class, markup=markup\n            )\n            # check the type of the example\n            example_id = example.main_id\n            examples[example_id] = example\n        return examples\n\n    @classmethod\n    def from_definition_string(\n        cls,\n        name: str,\n        definition_string: str,\n        content_class,\n        markup: str = \"json\",\n        debug: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        Load a DynamicCompetenceMap or Learner instance from a definition string (either JSON or YAML).\n\n        Args:\n            name (str): A name identifier for the data source.\n            definition_string (str): The string content of the definition.\n            content_class (dataclass_json): The class which will be instantiated with the parsed data.\n            markup (str): The markup format of the data. Defaults to 'json'. Supported values are 'json' and 'yaml'.\n            debug(bool): if True supply a JSON dump of the data in /tmp/{name}.json\n        Returns:\n            DynamicCompetenceMap: An instance of DynamicCompetenceMap loaded with the parsed data.\n\n        Raises:\n            ValueError: If there's an error in parsing the data.\n        \"\"\"\n        try:\n            data = cls.parse_markup(definition_string, markup)\n            if debug:\n                # Save the parsed data to a JSON file in /tmp directory\n                debug_file_path = os.path.join(\"/tmp\", f\"{name}.json\")\n                with open(debug_file_path, \"w\") as debug_file:\n                    json.dump(data, debug_file, indent=2, default=str)\n            content = content_class.from_dict(data)\n            if isinstance(content, CompetenceTree):\n                return DynamicCompetenceMap(content)\n            else:\n                return content\n        except Exception as ex:\n            cls.handle_markup_issue(name, definition_string, ex, markup)\n</code></pre>"},{"location":"#dcm.dcm_core.DynamicCompetenceMap.__init__","title":"<code>__init__(competence_tree, svg=None)</code>","text":"<p>constructor</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def __init__(self, competence_tree: CompetenceTree, svg: SVG = None):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.competence_tree = competence_tree\n    self.svg = svg\n</code></pre>"},{"location":"#dcm.dcm_core.DynamicCompetenceMap.from_definition_string","title":"<code>from_definition_string(name, definition_string, content_class, markup='json', debug=False)</code>  <code>classmethod</code>","text":"<p>Load a DynamicCompetenceMap or Learner instance from a definition string (either JSON or YAML).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A name identifier for the data source.</p> required <code>definition_string</code> <code>str</code> <p>The string content of the definition.</p> required <code>content_class</code> <code>dataclass_json</code> <p>The class which will be instantiated with the parsed data.</p> required <code>markup</code> <code>str</code> <p>The markup format of the data. Defaults to 'json'. Supported values are 'json' and 'yaml'.</p> <code>'json'</code> <code>debug(bool)</code> <p>if True supply a JSON dump of the data in /tmp/{name}.json</p> required <p>Returns:     DynamicCompetenceMap: An instance of DynamicCompetenceMap loaded with the parsed data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there's an error in parsing the data.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@classmethod\ndef from_definition_string(\n    cls,\n    name: str,\n    definition_string: str,\n    content_class,\n    markup: str = \"json\",\n    debug: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Load a DynamicCompetenceMap or Learner instance from a definition string (either JSON or YAML).\n\n    Args:\n        name (str): A name identifier for the data source.\n        definition_string (str): The string content of the definition.\n        content_class (dataclass_json): The class which will be instantiated with the parsed data.\n        markup (str): The markup format of the data. Defaults to 'json'. Supported values are 'json' and 'yaml'.\n        debug(bool): if True supply a JSON dump of the data in /tmp/{name}.json\n    Returns:\n        DynamicCompetenceMap: An instance of DynamicCompetenceMap loaded with the parsed data.\n\n    Raises:\n        ValueError: If there's an error in parsing the data.\n    \"\"\"\n    try:\n        data = cls.parse_markup(definition_string, markup)\n        if debug:\n            # Save the parsed data to a JSON file in /tmp directory\n            debug_file_path = os.path.join(\"/tmp\", f\"{name}.json\")\n            with open(debug_file_path, \"w\") as debug_file:\n                json.dump(data, debug_file, indent=2, default=str)\n        content = content_class.from_dict(data)\n        if isinstance(content, CompetenceTree):\n            return DynamicCompetenceMap(content)\n        else:\n            return content\n    except Exception as ex:\n        cls.handle_markup_issue(name, definition_string, ex, markup)\n</code></pre>"},{"location":"#dcm.dcm_core.DynamicCompetenceMap.get_example_dcm_definitions","title":"<code>get_example_dcm_definitions(markup='json', required_keys=None, as_text=True)</code>  <code>classmethod</code>","text":"<p>Retrieve example Dynamic Competence Map (DCM) definitions from files in the specified markup format (either JSON or YAML).</p> <p>Parameters:</p> Name Type Description Default <code>markup</code> <code>str</code> <p>The markup format of the input files. Defaults to 'json'. Supported values are 'json' and 'yaml'.</p> <code>'json'</code> <code>required_keys</code> <code>Optional[Tuple]</code> <p>A tuple of keys required to validate the data. If not provided, all keys will be considered valid.</p> <code>None</code> <code>as_text</code> <code>bool</code> <p>If True, returns the file content as text; if False, returns parsed data. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary where each key is the prefix of the file name and the value is the file content as text or parsed data, depending on the value of 'as_text'.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If there's an error in reading or parsing the file, or if the file does not meet the required validation criteria.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@classmethod\ndef get_example_dcm_definitions(\n    cls,\n    markup: str = \"json\",\n    required_keys: Optional[Tuple] = None,\n    as_text: bool = True,\n) -&gt; dict:\n    \"\"\"\n    Retrieve example Dynamic Competence Map (DCM) definitions from files in the specified markup format (either JSON or YAML).\n\n    Args:\n        markup (str): The markup format of the input files. Defaults to 'json'. Supported values are 'json' and 'yaml'.\n        required_keys (Optional[Tuple]): A tuple of keys required to validate the data. If not provided, all keys will be considered valid.\n        as_text (bool): If True, returns the file content as text; if False, returns parsed data. Defaults to True.\n\n    Returns:\n        dict: A dictionary where each key is the prefix of the file name and the value is the file content as text or parsed data, depending on the value of 'as_text'.\n\n    Raises:\n        Exception: If there's an error in reading or parsing the file, or if the file does not meet the required validation criteria.\n    \"\"\"\n    example_dcm_defs = {}\n    file_ext = f\".{markup}\"\n    examples_path = cls.examples_path()\n    for dirpath, _dirnames, filenames in os.walk(examples_path):\n        for filename in filenames:\n            if filename.endswith(file_ext):\n                filepath = os.path.join(dirpath, filename)\n                with open(filepath, \"r\") as definition_file:\n                    file_prefix = filename.replace(file_ext, \"\")\n                    definition_text = definition_file.read()\n                    try:\n                        definition_data = cls.parse_markup(definition_text, markup)\n                        if cls.is_valid_definition(definition_data, required_keys):\n                            if as_text:\n                                example_dcm_defs[file_prefix] = definition_text\n                            else:\n                                example_dcm_defs[file_prefix] = definition_data\n                    except Exception as ex:\n                        cls.handle_markup_issue(\n                            filename, definition_text, ex, markup\n                        )\n    return example_dcm_defs\n</code></pre>"},{"location":"#dcm.dcm_core.DynamicCompetenceMap.parse_markup","title":"<code>parse_markup(text, markup)</code>  <code>classmethod</code>","text":"<p>Parse the given text as JSON or YAML based on the specified markup type.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string content to be parsed.</p> required <code>markup</code> <code>str</code> <p>The type of markup to use for parsing. Supported values are 'json' and 'yaml'.</p> required <p>Returns:</p> Type Description <code>Union[dict, list]</code> <p>Union[dict, list]: The parsed data, which can be either a dictionary or a list, depending on the content.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported markup format is specified.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@classmethod\ndef parse_markup(cls, text: str, markup: str) -&gt; Union[dict, list]:\n    \"\"\"\n    Parse the given text as JSON or YAML based on the specified markup type.\n\n    Args:\n        text (str): The string content to be parsed.\n        markup (str): The type of markup to use for parsing. Supported values are 'json' and 'yaml'.\n\n    Returns:\n        Union[dict, list]: The parsed data, which can be either a dictionary or a list, depending on the content.\n\n    Raises:\n        ValueError: If an unsupported markup format is specified.\n    \"\"\"\n    if markup == \"json\":\n        data = json.loads(text)\n        return data\n    elif markup == \"yaml\":\n        data = yaml.safe_load(text)\n        return data\n    else:\n        raise ValueError(f\"Unsupported markup format: {markup}\")\n</code></pre>"},{"location":"#dcm.dcm_core.Learner","title":"<code>Learner</code>","text":"<p>A learner with achievements. Attributes:     learner_id (str): Identifier for the learner.     achievements (Dict[str, List[Achievement]]):         A dictionary where each key is a competence element identifier         and the value is a list of Achievement instances for that tree.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@lod_storable\nclass Learner:\n    \"\"\"\n    A learner with achievements.\n    Attributes:\n        learner_id (str): Identifier for the learner.\n        achievements (Dict[str, List[Achievement]]):\n            A dictionary where each key is a competence element identifier\n            and the value is a list of Achievement instances for that tree.\n    \"\"\"\n\n    learner_id: str\n    achievements: Optional[List[Achievement]] = field(default=None)\n\n    def __post_init__(self):\n        self.achievements_by_path = {}\n        self.achievement_indices_by_path = {}\n        if self.achievements:\n            for index, achievement in enumerate(self.achievements):\n                self.achievements_by_path[achievement.path] = achievement\n                self.achievement_indices_by_path[achievement.path] = index\n\n    @classmethod\n    def required_keys(cls):\n        keys = {\"achievements\"}\n        return keys\n\n    @property\n    def main_id(self):\n        main_id = self.learner_id\n        return main_id\n\n    @property\n    def file_name(self):\n        file_name = slugify(\n            self.learner_id, lowercase=False, regex_pattern=r\"[^\\w\\s\\-]\"\n        )\n        return file_name\n\n    @property\n    def most_recent_achievement_iso_date(self) -&gt; Optional[str]:\n        \"\"\"\n        Get the most recent achievement date in ISO format.\n\n        Returns:\n            Optional[str]: The ISO date string of the most recent achievement, or None if there are no achievements.\n        \"\"\"\n        if not self.achievements:\n            return None\n        dates = [\n            achievement.date_assessed_iso\n            for achievement in self.achievements\n            if achievement.date_assessed_iso\n        ]\n        if not dates:\n            return None\n        # Parse the ISO dates and return the most recent one\n        most_recent_date = max(datetime.fromisoformat(date) for date in dates)\n        return most_recent_date.isoformat()\n\n    def get_achievement_index(self, path) -&gt; int:\n        a_index = self.achievement_indices_by_path.get(path)\n        return a_index\n\n    def add_achievement(self, new_achievement):\n        \"\"\"\n        Add a new achievement for the learner.\n        \"\"\"\n        self.achievements.append(new_achievement)\n        index = len(self.achievements) - 1\n        self.achievements_by_path[new_achievement.path] = new_achievement\n        self.achievement_indices_by_path[new_achievement.path] = index\n\n    def get_competence_tree_ids(self) -&gt; List[str]:\n        \"\"\"\n        Get all unique competence tree IDs of my achievements.\n\n        Returns:\n            List[str]: A list of unique competence tree IDs.\n        \"\"\"\n        # Assuming that the learner's achievements are stored in a list called self.achievements\n        # You can modify this part according to your actual data structure.\n\n        # Create a set to store unique competence tree IDs\n        unique_tree_ids = set()\n\n        # Iterate through the learner's achievements\n        for achievement in self.achievements:\n            # Assuming each achievement has a tree_id attribute\n            tree_id = achievement.tree_id\n\n            # Add the tree_id to the set\n            unique_tree_ids.add(tree_id)\n\n        # Convert the set to a list and return\n        return list(unique_tree_ids)\n</code></pre>"},{"location":"#dcm.dcm_core.Learner.most_recent_achievement_iso_date","title":"<code>most_recent_achievement_iso_date: Optional[str]</code>  <code>property</code>","text":"<p>Get the most recent achievement date in ISO format.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The ISO date string of the most recent achievement, or None if there are no achievements.</p>"},{"location":"#dcm.dcm_core.Learner.add_achievement","title":"<code>add_achievement(new_achievement)</code>","text":"<p>Add a new achievement for the learner.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def add_achievement(self, new_achievement):\n    \"\"\"\n    Add a new achievement for the learner.\n    \"\"\"\n    self.achievements.append(new_achievement)\n    index = len(self.achievements) - 1\n    self.achievements_by_path[new_achievement.path] = new_achievement\n    self.achievement_indices_by_path[new_achievement.path] = index\n</code></pre>"},{"location":"#dcm.dcm_core.Learner.get_competence_tree_ids","title":"<code>get_competence_tree_ids()</code>","text":"<p>Get all unique competence tree IDs of my achievements.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of unique competence tree IDs.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>def get_competence_tree_ids(self) -&gt; List[str]:\n    \"\"\"\n    Get all unique competence tree IDs of my achievements.\n\n    Returns:\n        List[str]: A list of unique competence tree IDs.\n    \"\"\"\n    # Assuming that the learner's achievements are stored in a list called self.achievements\n    # You can modify this part according to your actual data structure.\n\n    # Create a set to store unique competence tree IDs\n    unique_tree_ids = set()\n\n    # Iterate through the learner's achievements\n    for achievement in self.achievements:\n        # Assuming each achievement has a tree_id attribute\n        tree_id = achievement.tree_id\n\n        # Add the tree_id to the set\n        unique_tree_ids.add(tree_id)\n\n    # Convert the set to a list and return\n    return list(unique_tree_ids)\n</code></pre>"},{"location":"#dcm.dcm_core.RingSpec","title":"<code>RingSpec</code>  <code>dataclass</code>","text":"<p>Specification of rings of the donut chart.</p> <p>Attributes:</p> Name Type Description <code>text_mode</code> <code>Optional[str]</code> <p>The mode of text display on the ring. Default is None.</p> <code>inner_ratio</code> <code>Optional[float]</code> <p>The inner radius of the ring, relative to the chart size.</p> <code>outer_ratio</code> <code>Optional[float]</code> <p>The outer radius of the ring, relative to the chart size.</p> <code>symmetry_mode</code> <code>Optional[str]</code> <p>Specifies the symmetry mode for the ring. Supports \"count\", \"time\", \"score\" to determine how the ring segments are balanced. Default is None.</p> Source code in <code>dcm/dcm_core.py</code> <pre><code>@dataclass_json\n@dataclass\nclass RingSpec:\n    \"\"\"\n    Specification of rings of the donut chart.\n\n    Attributes:\n        text_mode (Optional[str]): The mode of text display on the ring. Default is None.\n        inner_ratio (Optional[float]): The inner radius of the ring, relative to the chart size.\n        outer_ratio (Optional[float]): The outer radius of the ring, relative to the chart size.\n        symmetry_mode (Optional[str]): Specifies the symmetry mode for the ring. Supports \"count\", \"time\", \"score\" to determine how the ring segments are balanced. Default is None.\n    \"\"\"\n\n    text_mode: Optional[str] = \"empty\"\n    inner_ratio: Optional[float] = None\n    outer_ratio: Optional[float] = None\n    levels_visible: Optional[bool] = False\n    symmetry_mode: Optional[str] = None\n\n    @property\n    def empty(self) -&gt; bool:\n        empty = (\n            self.inner_ratio is None\n            or self.outer_ratio is None\n            or (self.inner_ratio + self.outer_ratio) == 0.0\n        )\n        return empty\n</code></pre>"},{"location":"#dcm.dcm_web","title":"<code>dcm_web</code>","text":"<p>Created on 2024-01-26</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_web.RingSpecView","title":"<code>RingSpecView</code>","text":"<p>show a single ring specification</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>class RingSpecView:\n    \"\"\"\n    show a single ring specification\n    \"\"\"\n\n    def __init__(\n        self, parent, ring_level: str, ringspec: RingSpec, throttle: float = 0.1\n    ):\n        \"\"\"\n        construct me\n        \"\"\"\n        self.parent = parent\n        self.ringspec = ringspec\n        self.ring_level = ring_level\n        self.ringspec = ringspec\n        self.change_enabled = False\n        self.throttle = throttle\n        self.setup_ui()\n\n    def setup_ui(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with self.parent.grid:\n            selection = [\"empty\", \"curved\", \"horizontal\", \"angled\"]\n            self.text_mode_select = self.parent.webserver.add_select(\n                self.ring_level,\n                selection,\n                value=self.ringspec.text_mode,\n                on_change=self.on_text_mode_change,\n            )\n            self.level_visible_checkbox = ui.checkbox(\"level\").on(\n                \"click\", self.on_level_visible_change\n            )\n            self.inner_ratio_slider = (\n                ui.slider(min=0, max=1.0, step=0.01, value=self.ringspec.inner_ratio)\n                .props(\"label-always\")\n                .on(\n                    \"update:model-value\",\n                    self.on_inner_ratio_change,\n                    throttle=self.throttle,\n                )\n            )\n            self.outer_ratio_slider = (\n                ui.slider(min=0, max=1.0, step=0.01, value=self.ringspec.outer_ratio)\n                .props(\"label-always\")\n                .on(\n                    \"update:model-value\",\n                    self.on_outer_ratio_change,\n                    throttle=self.throttle,\n                )\n            )\n\n    def update(self, rs: RingSpec):\n        \"\"\"\n        update the ring specification to be modified by this ui\n        \"\"\"\n        self.ringspec = rs\n        self.change_enabled = False\n        self.text_mode_select.value = rs.text_mode\n        self.inner_ratio_slider.value = round(rs.inner_ratio, 2)\n        self.outer_ratio_slider.value = round(rs.outer_ratio, 2)\n        self.change_enabled = True\n\n    def on_level_visible_change(self):\n        \"\"\" \"\"\"\n        self.ringspec.levels_visible = self.level_visible_checkbox.value\n        self.parent.on_change()\n\n    def on_inner_ratio_change(self, gev: GenericEventArguments):\n        \"\"\"\n        Handle changes in the inner_ratio slider.\n        \"\"\"\n        if self.change_enabled:\n            self.ringspec.inner_ratio = gev.args\n            self.parent.on_change()\n\n    def on_outer_ratio_change(self, gev: GenericEventArguments):\n        \"\"\"\n        Handle changes in the outer_ratio slider.\n        \"\"\"\n        if self.change_enabled:\n            self.ringspec.outer_ratio = gev.args\n            self.parent.on_change()\n\n    async def on_text_mode_change(self, args):\n        \"\"\"\n        handle changes in the text_mode\n        \"\"\"\n        # ignore changes if change_enabled is not active\n        if not self.change_enabled:\n            return\n        new_text_mode = args.value\n        if new_text_mode != self.ringspec.text_mode:\n            self.ringspec.text_mode = new_text_mode\n        self.parent.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.__init__","title":"<code>__init__(parent, ring_level, ringspec, throttle=0.1)</code>","text":"<p>construct me</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def __init__(\n    self, parent, ring_level: str, ringspec: RingSpec, throttle: float = 0.1\n):\n    \"\"\"\n    construct me\n    \"\"\"\n    self.parent = parent\n    self.ringspec = ringspec\n    self.ring_level = ring_level\n    self.ringspec = ringspec\n    self.change_enabled = False\n    self.throttle = throttle\n    self.setup_ui()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.on_inner_ratio_change","title":"<code>on_inner_ratio_change(gev)</code>","text":"<p>Handle changes in the inner_ratio slider.</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def on_inner_ratio_change(self, gev: GenericEventArguments):\n    \"\"\"\n    Handle changes in the inner_ratio slider.\n    \"\"\"\n    if self.change_enabled:\n        self.ringspec.inner_ratio = gev.args\n        self.parent.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.on_level_visible_change","title":"<code>on_level_visible_change()</code>","text":"Source code in <code>dcm/dcm_web.py</code> <pre><code>def on_level_visible_change(self):\n    \"\"\" \"\"\"\n    self.ringspec.levels_visible = self.level_visible_checkbox.value\n    self.parent.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.on_outer_ratio_change","title":"<code>on_outer_ratio_change(gev)</code>","text":"<p>Handle changes in the outer_ratio slider.</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def on_outer_ratio_change(self, gev: GenericEventArguments):\n    \"\"\"\n    Handle changes in the outer_ratio slider.\n    \"\"\"\n    if self.change_enabled:\n        self.ringspec.outer_ratio = gev.args\n        self.parent.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.on_text_mode_change","title":"<code>on_text_mode_change(args)</code>  <code>async</code>","text":"<p>handle changes in the text_mode</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>async def on_text_mode_change(self, args):\n    \"\"\"\n    handle changes in the text_mode\n    \"\"\"\n    # ignore changes if change_enabled is not active\n    if not self.change_enabled:\n        return\n    new_text_mode = args.value\n    if new_text_mode != self.ringspec.text_mode:\n        self.ringspec.text_mode = new_text_mode\n    self.parent.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup the user interface</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with self.parent.grid:\n        selection = [\"empty\", \"curved\", \"horizontal\", \"angled\"]\n        self.text_mode_select = self.parent.webserver.add_select(\n            self.ring_level,\n            selection,\n            value=self.ringspec.text_mode,\n            on_change=self.on_text_mode_change,\n        )\n        self.level_visible_checkbox = ui.checkbox(\"level\").on(\n            \"click\", self.on_level_visible_change\n        )\n        self.inner_ratio_slider = (\n            ui.slider(min=0, max=1.0, step=0.01, value=self.ringspec.inner_ratio)\n            .props(\"label-always\")\n            .on(\n                \"update:model-value\",\n                self.on_inner_ratio_change,\n                throttle=self.throttle,\n            )\n        )\n        self.outer_ratio_slider = (\n            ui.slider(min=0, max=1.0, step=0.01, value=self.ringspec.outer_ratio)\n            .props(\"label-always\")\n            .on(\n                \"update:model-value\",\n                self.on_outer_ratio_change,\n                throttle=self.throttle,\n            )\n        )\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecView.update","title":"<code>update(rs)</code>","text":"<p>update the ring specification to be modified by this ui</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def update(self, rs: RingSpec):\n    \"\"\"\n    update the ring specification to be modified by this ui\n    \"\"\"\n    self.ringspec = rs\n    self.change_enabled = False\n    self.text_mode_select.value = rs.text_mode\n    self.inner_ratio_slider.value = round(rs.inner_ratio, 2)\n    self.outer_ratio_slider.value = round(rs.outer_ratio, 2)\n    self.change_enabled = True\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecsView","title":"<code>RingSpecsView</code>","text":"<p>show a list of ringspecs</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>class RingSpecsView:\n    \"\"\"\n    show a list of ringspecs\n    \"\"\"\n\n    def __init__(self, webserver):\n        self.webserver = webserver\n        self.ct = None\n        # ringspec views\n        self.rsv = {}\n        self.setup_ui()\n        self.symmetry_mode = None\n        self.symmetry_level = None\n\n    def setup_ui(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with ui.expansion(\"ring specs\", icon=\"settings\") as self.expansion:\n            with ui.expansion(\"symmetry\", icon=\"balance\"):\n                with ui.row():\n                    self.symmetry_mode_radio = ui.radio(\n                        [\"count\", \"time\", \"score\"], on_change=self.on_symmetry_change\n                    ).props(\"inline\")\n                with ui.row():\n                    self.symmetry_level_radio = ui.radio(\n                        [\"aspect\", \"area\", \"facet\"], on_change=self.on_symmetry_change\n                    ).props(\"inline\")\n            with ui.grid(columns=2, rows=8) as self.grid:\n                inner_ratio = 0\n                outer_ratio = 1 / 7\n                levels = [\"tree\", \"aspect\", \"area\", \"facet\"]\n                for rl in levels:\n                    rs = RingSpec(\n                        text_mode=\"empty\",\n                        inner_ratio=round(inner_ratio, 2),\n                        outer_ratio=round(outer_ratio, 2),\n                    )\n                    self.rsv[rl] = RingSpecView(self, rl, rs)\n                    inner_ratio = outer_ratio\n                    outer_ratio = outer_ratio + 2 / 7\n\n    def update_rings(self, ct: CompetenceTree):\n        \"\"\"\n        update the ring specifications based on the given competence tree\n        \"\"\"\n        self.symmetry_level, self.symmetry_mode = ct.get_symmetry_spec()\n        self.symmetry_level_radio.value = self.symmetry_level\n        self.symmetry_mode_radio.value = self.symmetry_mode\n        # set ct after changing radio buttions\n        self.ct = ct\n        for rl in [\"tree\", \"aspect\", \"area\", \"facet\"]:\n            self.rsv[rl].update(ct.ring_specs[rl])\n\n    def on_symmetry_change(self, args):\n        \"\"\"\n        handle symmetry changes\n        \"\"\"\n        if self.ct:\n            # get compentency tree symmetry settings\n            # and the current ui radio button settings\n            ct_symmetry_level, ct_symmetry_mode = self.ct.get_symmetry_spec()\n            self.symmetry_level = self.symmetry_level_radio.value\n            self.symmetry_mode = self.symmetry_mode_radio.value\n            # check whether the radio values are different from the ct values\n            if (\n                ct_symmetry_level != self.symmetry_level\n                or ct_symmetry_mode != self.symmetry_mode\n            ):\n                self.ct.set_symmetry_mode(self.symmetry_level, self.symmetry_mode)\n            pass\n        self.on_change()\n\n    def on_change(self):\n        \"\"\"\n        if a ring spec trigger update\n        \"\"\"\n        self.webserver.on_update_ringspecs()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecsView.on_change","title":"<code>on_change()</code>","text":"<p>if a ring spec trigger update</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def on_change(self):\n    \"\"\"\n    if a ring spec trigger update\n    \"\"\"\n    self.webserver.on_update_ringspecs()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecsView.on_symmetry_change","title":"<code>on_symmetry_change(args)</code>","text":"<p>handle symmetry changes</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def on_symmetry_change(self, args):\n    \"\"\"\n    handle symmetry changes\n    \"\"\"\n    if self.ct:\n        # get compentency tree symmetry settings\n        # and the current ui radio button settings\n        ct_symmetry_level, ct_symmetry_mode = self.ct.get_symmetry_spec()\n        self.symmetry_level = self.symmetry_level_radio.value\n        self.symmetry_mode = self.symmetry_mode_radio.value\n        # check whether the radio values are different from the ct values\n        if (\n            ct_symmetry_level != self.symmetry_level\n            or ct_symmetry_mode != self.symmetry_mode\n        ):\n            self.ct.set_symmetry_mode(self.symmetry_level, self.symmetry_mode)\n        pass\n    self.on_change()\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecsView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>setup the user interface</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with ui.expansion(\"ring specs\", icon=\"settings\") as self.expansion:\n        with ui.expansion(\"symmetry\", icon=\"balance\"):\n            with ui.row():\n                self.symmetry_mode_radio = ui.radio(\n                    [\"count\", \"time\", \"score\"], on_change=self.on_symmetry_change\n                ).props(\"inline\")\n            with ui.row():\n                self.symmetry_level_radio = ui.radio(\n                    [\"aspect\", \"area\", \"facet\"], on_change=self.on_symmetry_change\n                ).props(\"inline\")\n        with ui.grid(columns=2, rows=8) as self.grid:\n            inner_ratio = 0\n            outer_ratio = 1 / 7\n            levels = [\"tree\", \"aspect\", \"area\", \"facet\"]\n            for rl in levels:\n                rs = RingSpec(\n                    text_mode=\"empty\",\n                    inner_ratio=round(inner_ratio, 2),\n                    outer_ratio=round(outer_ratio, 2),\n                )\n                self.rsv[rl] = RingSpecView(self, rl, rs)\n                inner_ratio = outer_ratio\n                outer_ratio = outer_ratio + 2 / 7\n</code></pre>"},{"location":"#dcm.dcm_web.RingSpecsView.update_rings","title":"<code>update_rings(ct)</code>","text":"<p>update the ring specifications based on the given competence tree</p> Source code in <code>dcm/dcm_web.py</code> <pre><code>def update_rings(self, ct: CompetenceTree):\n    \"\"\"\n    update the ring specifications based on the given competence tree\n    \"\"\"\n    self.symmetry_level, self.symmetry_mode = ct.get_symmetry_spec()\n    self.symmetry_level_radio.value = self.symmetry_level\n    self.symmetry_mode_radio.value = self.symmetry_mode\n    # set ct after changing radio buttions\n    self.ct = ct\n    for rl in [\"tree\", \"aspect\", \"area\", \"facet\"]:\n        self.rsv[rl].update(ct.ring_specs[rl])\n</code></pre>"},{"location":"#dcm.dcm_webserver","title":"<code>dcm_webserver</code>","text":"<p>Created on 2023-11-06</p> <p>@author: wf</p>"},{"location":"#dcm.dcm_webserver.DcmSolution","title":"<code>DcmSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Dynamic Competence Map solution</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>class DcmSolution(InputWebSolution):\n    \"\"\"\n    the Dynamic Competence Map solution\n    \"\"\"\n\n    def __init__(self, webserver: DynamicCompentenceMapWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.dcm = None\n        self.learner = None\n        self.assessment = None\n        self.text_mode = \"empty\"\n\n    def get_basename_without_extension(self, url) -&gt; str:\n        # Parse the URL to get the path component\n        path = urlparse(url).path\n        # Extract the base name (e.g., \"example.html\" from \"/dir/example.html\")\n        basename = os.path.basename(path)\n        # Split the base name and extension and return just the base name\n        return os.path.splitext(basename)[0]\n\n    def save_session_state(self) -&gt; None:\n        \"\"\"\n        Save the current session state to app.storage.user.\n        \"\"\"\n        learner_id = self.learner.learner_id if self.learner else None\n        app.storage.user[\"learner_id\"] = learner_id\n        app.storage.user[\"assessment\"] = self.assessment is not None\n\n    def get_learner_file_path(self, learner_slug: str) -&gt; str:\n        \"\"\"\n        Get the file path for a learner's JSON file based on the learner's slug.\n\n        Args:\n            learner_slug (str): The unique slug of the learner.\n\n        Returns:\n            str: The file path for the learner's JSON file.\n        \"\"\"\n        return os.path.join(self.config.storage_path, f\"{learner_slug}.json\")\n\n    def load_learner(self, learner_slug: str) -&gt; None:\n        \"\"\"\n        Load a learner from a JSON file based on the learner's slug.\n\n        Args:\n            learner_slug (str): The unique slug of the learner.\n\n        Raises:\n            FileNotFoundError: If the learner file does not exist.\n        \"\"\"\n        learner_file = self.get_learner_file_path(learner_slug)\n        if not os.path.exists(learner_file):\n            raise FileNotFoundError(f\"Learner file not found: {learner_file}\")\n        self.learner = Learner.load_from_json_file(learner_file)\n        self.save_session_state()\n\n    async def render(self, _click_args=None):\n        \"\"\"\n        Renders the json content as an SVG visualization\n\n        Args:\n            click_args (object): The click event arguments.\n        \"\"\"\n        try:\n            input_source = self.input\n            if input_source:\n                name = self.get_basename_without_extension(input_source)\n                with self.content_div:\n                    ui.notify(f\"rendering {name}\")\n                definition = self.do_read_input(input_source)\n                # Determine the format based on the file extension\n                markup = \"json\" if input_source.endswith(\".json\") else \"yaml\"\n                if \"learner_id\" in definition:\n                    content_class = Learner\n                else:\n                    content_class = CompetenceTree\n                item = DynamicCompetenceMap.from_definition_string(\n                    name, definition, content_class=content_class, markup=markup\n                )\n                self.render_item(item)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def render_item(self, item):\n        if isinstance(item, DynamicCompetenceMap):\n            self.render_dcm(item)\n        else:\n            self.learner = item\n            self.save_session_state()\n            self.assess(item)\n\n    def render_dcm(\n        self,\n        dcm,\n        learner: Learner = None,\n        selected_paths: List = [],\n        clear_assessment: bool = True,\n    ):\n        \"\"\"\n        render the dynamic competence map\n\n        Args:\n            dcm(DynamicCompetenceMap)\n            selected_paths (List, optional): A list of paths that should be highlighted\n            in the SVG. These paths typically represent specific competencies or\n            achievements. Defaults to an empty list.\n\n        \"\"\"\n        try:\n            if clear_assessment and self.assessment:\n                try:\n                    self.assessment_row.clear()\n                except Exception as ex:\n                    ui.notify(str(ex))\n                self.assessment = None\n                self.learner = None\n            self.dcm = dcm\n            self.ringspecs_view.update_rings(dcm.competence_tree)\n            self.assess_state()\n            dcm_chart = DcmChart(dcm)\n            svg_markup = dcm_chart.generate_svg_markup(\n                learner=learner,\n                selected_paths=selected_paths,\n                config=self.svg.config,\n                with_java_script=False,\n                text_mode=self.text_mode,\n            )\n            # Use the new get_java_script method to get the JavaScript\n            self.svg_view.content = (svg_markup,)\n            self.svg_view.update()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    def prepare_ui(self):\n        \"\"\"\n        prepare the user interface\n        \"\"\"\n        self.user_id = app.storage.browser[\"id\"]\n        self.prepare_svg()\n\n    def prepare_svg(self):\n        \"\"\"\n        prepare the SVG / javascript display\n        \"\"\"\n        config = SVGConfig(with_popup=True)\n        self.svg = SVG(config=config)\n        java_script = self.svg.get_java_script()\n\n        # Add the script using ui.add_head_html()\n        ui.add_head_html(java_script, shared=True)\n\n    def show_ui(self):\n        \"\"\"\n        show the ui\n        \"\"\"\n        with self.content_div:\n            with ui.splitter() as splitter:\n                with splitter.before:\n                    with ui.grid(columns=2).classes(\"w-full\") as self.left_selection:\n                        extensions = {\"json\": \".json\", \"yaml\": \".yaml\"}\n                        self.example_selector = FileSelector(\n                            path=self.webserver.root_path,\n                            extensions=extensions,\n                            handler=self.read_and_optionally_render,\n                        )\n                        self.ringspecs_view = RingSpecsView(self)\n                    with ui.grid(columns=1).classes(\"w-full\") as self.left_grid:\n                        with ui.row() as self.input_row:\n                            self.input_input = ui.input(\n                                value=self.input, on_change=self.input_changed\n                            ).props(\"size=100\")\n                        with ui.row() as self.button_row:\n                            self.tool_button(\n                                tooltip=\"reload\",\n                                icon=\"refresh\",\n                                handler=self.reload_file,\n                            )\n                            self.assessment_button = self.tool_button(\n                                tooltip=\"assessment\",\n                                icon=\"query_stats\",\n                                handler=self.new_assess,\n                            )\n                            if self.is_local:\n                                self.tool_button(\n                                    tooltip=\"open\",\n                                    icon=\"file_open\",\n                                    handler=self.open_file,\n                                )\n                            self.download_button = self.tool_button(\n                                tooltip=\"download\",\n                                icon=\"download\",\n                                handler=self.download,\n                            )\n                with splitter.after:\n                    self.svg_view = ui.html(\"\")\n\n    async def home(\n        self,\n    ):\n        \"\"\"Generates the home page with a selection of examples and\n        svg display\n        \"\"\"\n        await self.setup_content_div(self.show_ui)\n        self.assess_state()\n\n    def assess_learner(self, dcm, learner):\n        \"\"\"\n        assess the given Dynamic Competence Map and learner\n\n        Args:\n            dcm(DynamicCompetenceMap): the competence map\n            learner(Learner): the learner to get the self assessment for\n\n        \"\"\"\n        if not self.content_div:\n            return\n        with self.content_div:\n            if self.assessment is not None:\n                self.assessment.reset(dcm=dcm, learner=learner)\n            else:\n                with self.left_grid:\n                    with ui.row() as self.assessment_row:\n                        self.assessment = Assessment(self, dcm=dcm, learner=learner)\n            self.assessment.step(0)\n\n    def new_assess(self):\n        \"\"\"\n        run a new  assessment for a new learner\n        \"\"\"\n        try:\n            learner_id = f\"{uuid.uuid4()}\"\n            self.learner = Learner(learner_id)\n            self.save_session_state()\n            self.assess_learner(self.dcm, self.learner)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    async def assess_learner_by_slug(self, learner_slug: str):\n        \"\"\"\n        Assess a learner based on the slug of the id\n\n        Args:\n            learner_slug (str): The unique slug of the learner.\n\n        Raises:\n            HTTPException: If the learner file does not exist or an error occurs.\n        \"\"\"\n\n        def show():\n            try:\n                self.show_ui()\n                self.load_learner(learner_slug)\n                self.assess(self.learner)\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(show)\n\n    def assess(self, learner: Learner, tree_id: str = None):\n        \"\"\"\n        run an assessment for the given learner\n\n        Args:\n            learner(Learner): the learner to get the self assessment for\n            tree_id(str): the identifier for the competence tree\n        \"\"\"\n        if tree_id is None:\n            tree_ids = learner.get_competence_tree_ids()\n            if len(tree_ids) != 1:\n                raise Exception(\n                    f\"There must be exactly one competence tree referenced but there are: {tree_ids}\"\n                )\n            tree_id = tree_ids[0]\n        if not tree_id in self.webserver.examples:\n            raise Exception(f\"invalid competence tree_id {tree_id}\")\n        dcm = self.webserver.examples[tree_id]\n        # assess_learner will render ...\n        # self.render_dcm(dcm,learner=learner)\n        self.assess_learner(dcm, learner)\n\n    def on_update_ringspecs(self):\n        \"\"\"\n        react on changes in the ringspecs\n        \"\"\"\n        if self.learner:\n            self.render_item(self.learner)\n        else:\n            self.render_item(self.dcm)\n\n    def assess_state(self):\n        \"\"\"\n        save the session state and reflect\n        in the UI\n        \"\"\"\n        self.save_session_state()\n        if self.dcm and self.learner is None:\n            # allow creating a new learner\n            self.assessment_button.enable()\n        else:\n            # the assessment is already on\n            self.assessment_button.disable()\n        if self.assessment is not None:\n            # downloading is possible\n            self.download_button.enable()\n        else:\n            # downloading is not possible - we have n learner\n            self.download_button.disable()\n\n    async def download(self, _args):\n        \"\"\"\n        allow downloading the assessment result\n        \"\"\"\n        try:\n            with self.content_div:\n                if not self.assessment:\n                    ui.notify(\"no active learner assessment\")\n                    return\n                json_path = self.assessment.store()\n                ui.notify(f\"downloading {json_path}\")\n                ui.download(json_path)\n        except Exception as ex:\n            self.handle_exception(ex)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def __init__(self, webserver: DynamicCompentenceMapWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (DynamicCompotenceMapWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.dcm = None\n    self.learner = None\n    self.assessment = None\n    self.text_mode = \"empty\"\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.assess","title":"<code>assess(learner, tree_id=None)</code>","text":"<p>run an assessment for the given learner</p> <p>Parameters:</p> Name Type Description Default <code>learner(Learner)</code> <p>the learner to get the self assessment for</p> required <code>tree_id(str)</code> <p>the identifier for the competence tree</p> required Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def assess(self, learner: Learner, tree_id: str = None):\n    \"\"\"\n    run an assessment for the given learner\n\n    Args:\n        learner(Learner): the learner to get the self assessment for\n        tree_id(str): the identifier for the competence tree\n    \"\"\"\n    if tree_id is None:\n        tree_ids = learner.get_competence_tree_ids()\n        if len(tree_ids) != 1:\n            raise Exception(\n                f\"There must be exactly one competence tree referenced but there are: {tree_ids}\"\n            )\n        tree_id = tree_ids[0]\n    if not tree_id in self.webserver.examples:\n        raise Exception(f\"invalid competence tree_id {tree_id}\")\n    dcm = self.webserver.examples[tree_id]\n    # assess_learner will render ...\n    # self.render_dcm(dcm,learner=learner)\n    self.assess_learner(dcm, learner)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.assess_learner","title":"<code>assess_learner(dcm, learner)</code>","text":"<p>assess the given Dynamic Competence Map and learner</p> <p>Parameters:</p> Name Type Description Default <code>dcm(DynamicCompetenceMap)</code> <p>the competence map</p> required <code>learner(Learner)</code> <p>the learner to get the self assessment for</p> required Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def assess_learner(self, dcm, learner):\n    \"\"\"\n    assess the given Dynamic Competence Map and learner\n\n    Args:\n        dcm(DynamicCompetenceMap): the competence map\n        learner(Learner): the learner to get the self assessment for\n\n    \"\"\"\n    if not self.content_div:\n        return\n    with self.content_div:\n        if self.assessment is not None:\n            self.assessment.reset(dcm=dcm, learner=learner)\n        else:\n            with self.left_grid:\n                with ui.row() as self.assessment_row:\n                    self.assessment = Assessment(self, dcm=dcm, learner=learner)\n        self.assessment.step(0)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.assess_learner_by_slug","title":"<code>assess_learner_by_slug(learner_slug)</code>  <code>async</code>","text":"<p>Assess a learner based on the slug of the id</p> <p>Parameters:</p> Name Type Description Default <code>learner_slug</code> <code>str</code> <p>The unique slug of the learner.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the learner file does not exist or an error occurs.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def assess_learner_by_slug(self, learner_slug: str):\n    \"\"\"\n    Assess a learner based on the slug of the id\n\n    Args:\n        learner_slug (str): The unique slug of the learner.\n\n    Raises:\n        HTTPException: If the learner file does not exist or an error occurs.\n    \"\"\"\n\n    def show():\n        try:\n            self.show_ui()\n            self.load_learner(learner_slug)\n            self.assess(self.learner)\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.assess_state","title":"<code>assess_state()</code>","text":"<p>save the session state and reflect in the UI</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def assess_state(self):\n    \"\"\"\n    save the session state and reflect\n    in the UI\n    \"\"\"\n    self.save_session_state()\n    if self.dcm and self.learner is None:\n        # allow creating a new learner\n        self.assessment_button.enable()\n    else:\n        # the assessment is already on\n        self.assessment_button.disable()\n    if self.assessment is not None:\n        # downloading is possible\n        self.download_button.enable()\n    else:\n        # downloading is not possible - we have n learner\n        self.download_button.disable()\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.download","title":"<code>download(_args)</code>  <code>async</code>","text":"<p>allow downloading the assessment result</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def download(self, _args):\n    \"\"\"\n    allow downloading the assessment result\n    \"\"\"\n    try:\n        with self.content_div:\n            if not self.assessment:\n                ui.notify(\"no active learner assessment\")\n                return\n            json_path = self.assessment.store()\n            ui.notify(f\"downloading {json_path}\")\n            ui.download(json_path)\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.get_learner_file_path","title":"<code>get_learner_file_path(learner_slug)</code>","text":"<p>Get the file path for a learner's JSON file based on the learner's slug.</p> <p>Parameters:</p> Name Type Description Default <code>learner_slug</code> <code>str</code> <p>The unique slug of the learner.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The file path for the learner's JSON file.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def get_learner_file_path(self, learner_slug: str) -&gt; str:\n    \"\"\"\n    Get the file path for a learner's JSON file based on the learner's slug.\n\n    Args:\n        learner_slug (str): The unique slug of the learner.\n\n    Returns:\n        str: The file path for the learner's JSON file.\n    \"\"\"\n    return os.path.join(self.config.storage_path, f\"{learner_slug}.json\")\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>Generates the home page with a selection of examples and svg display</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def home(\n    self,\n):\n    \"\"\"Generates the home page with a selection of examples and\n    svg display\n    \"\"\"\n    await self.setup_content_div(self.show_ui)\n    self.assess_state()\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.load_learner","title":"<code>load_learner(learner_slug)</code>","text":"<p>Load a learner from a JSON file based on the learner's slug.</p> <p>Parameters:</p> Name Type Description Default <code>learner_slug</code> <code>str</code> <p>The unique slug of the learner.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the learner file does not exist.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def load_learner(self, learner_slug: str) -&gt; None:\n    \"\"\"\n    Load a learner from a JSON file based on the learner's slug.\n\n    Args:\n        learner_slug (str): The unique slug of the learner.\n\n    Raises:\n        FileNotFoundError: If the learner file does not exist.\n    \"\"\"\n    learner_file = self.get_learner_file_path(learner_slug)\n    if not os.path.exists(learner_file):\n        raise FileNotFoundError(f\"Learner file not found: {learner_file}\")\n    self.learner = Learner.load_from_json_file(learner_file)\n    self.save_session_state()\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.new_assess","title":"<code>new_assess()</code>","text":"<p>run a new  assessment for a new learner</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def new_assess(self):\n    \"\"\"\n    run a new  assessment for a new learner\n    \"\"\"\n    try:\n        learner_id = f\"{uuid.uuid4()}\"\n        self.learner = Learner(learner_id)\n        self.save_session_state()\n        self.assess_learner(self.dcm, self.learner)\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.on_update_ringspecs","title":"<code>on_update_ringspecs()</code>","text":"<p>react on changes in the ringspecs</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def on_update_ringspecs(self):\n    \"\"\"\n    react on changes in the ringspecs\n    \"\"\"\n    if self.learner:\n        self.render_item(self.learner)\n    else:\n        self.render_item(self.dcm)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.prepare_svg","title":"<code>prepare_svg()</code>","text":"<p>prepare the SVG / javascript display</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def prepare_svg(self):\n    \"\"\"\n    prepare the SVG / javascript display\n    \"\"\"\n    config = SVGConfig(with_popup=True)\n    self.svg = SVG(config=config)\n    java_script = self.svg.get_java_script()\n\n    # Add the script using ui.add_head_html()\n    ui.add_head_html(java_script, shared=True)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.prepare_ui","title":"<code>prepare_ui()</code>","text":"<p>prepare the user interface</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def prepare_ui(self):\n    \"\"\"\n    prepare the user interface\n    \"\"\"\n    self.user_id = app.storage.browser[\"id\"]\n    self.prepare_svg()\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.render","title":"<code>render(_click_args=None)</code>  <code>async</code>","text":"<p>Renders the json content as an SVG visualization</p> <p>Parameters:</p> Name Type Description Default <code>click_args</code> <code>object</code> <p>The click event arguments.</p> required Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def render(self, _click_args=None):\n    \"\"\"\n    Renders the json content as an SVG visualization\n\n    Args:\n        click_args (object): The click event arguments.\n    \"\"\"\n    try:\n        input_source = self.input\n        if input_source:\n            name = self.get_basename_without_extension(input_source)\n            with self.content_div:\n                ui.notify(f\"rendering {name}\")\n            definition = self.do_read_input(input_source)\n            # Determine the format based on the file extension\n            markup = \"json\" if input_source.endswith(\".json\") else \"yaml\"\n            if \"learner_id\" in definition:\n                content_class = Learner\n            else:\n                content_class = CompetenceTree\n            item = DynamicCompetenceMap.from_definition_string(\n                name, definition, content_class=content_class, markup=markup\n            )\n            self.render_item(item)\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.render_dcm","title":"<code>render_dcm(dcm, learner=None, selected_paths=[], clear_assessment=True)</code>","text":"<p>render the dynamic competence map</p> <p>Parameters:</p> Name Type Description Default <code>selected_paths</code> <code>List</code> <p>A list of paths that should be highlighted</p> <code>[]</code> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def render_dcm(\n    self,\n    dcm,\n    learner: Learner = None,\n    selected_paths: List = [],\n    clear_assessment: bool = True,\n):\n    \"\"\"\n    render the dynamic competence map\n\n    Args:\n        dcm(DynamicCompetenceMap)\n        selected_paths (List, optional): A list of paths that should be highlighted\n        in the SVG. These paths typically represent specific competencies or\n        achievements. Defaults to an empty list.\n\n    \"\"\"\n    try:\n        if clear_assessment and self.assessment:\n            try:\n                self.assessment_row.clear()\n            except Exception as ex:\n                ui.notify(str(ex))\n            self.assessment = None\n            self.learner = None\n        self.dcm = dcm\n        self.ringspecs_view.update_rings(dcm.competence_tree)\n        self.assess_state()\n        dcm_chart = DcmChart(dcm)\n        svg_markup = dcm_chart.generate_svg_markup(\n            learner=learner,\n            selected_paths=selected_paths,\n            config=self.svg.config,\n            with_java_script=False,\n            text_mode=self.text_mode,\n        )\n        # Use the new get_java_script method to get the JavaScript\n        self.svg_view.content = (svg_markup,)\n        self.svg_view.update()\n    except Exception as ex:\n        self.handle_exception(ex)\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.save_session_state","title":"<code>save_session_state()</code>","text":"<p>Save the current session state to app.storage.user.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def save_session_state(self) -&gt; None:\n    \"\"\"\n    Save the current session state to app.storage.user.\n    \"\"\"\n    learner_id = self.learner.learner_id if self.learner else None\n    app.storage.user[\"learner_id\"] = learner_id\n    app.storage.user[\"assessment\"] = self.assessment is not None\n</code></pre>"},{"location":"#dcm.dcm_webserver.DcmSolution.show_ui","title":"<code>show_ui()</code>","text":"<p>show the ui</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def show_ui(self):\n    \"\"\"\n    show the ui\n    \"\"\"\n    with self.content_div:\n        with ui.splitter() as splitter:\n            with splitter.before:\n                with ui.grid(columns=2).classes(\"w-full\") as self.left_selection:\n                    extensions = {\"json\": \".json\", \"yaml\": \".yaml\"}\n                    self.example_selector = FileSelector(\n                        path=self.webserver.root_path,\n                        extensions=extensions,\n                        handler=self.read_and_optionally_render,\n                    )\n                    self.ringspecs_view = RingSpecsView(self)\n                with ui.grid(columns=1).classes(\"w-full\") as self.left_grid:\n                    with ui.row() as self.input_row:\n                        self.input_input = ui.input(\n                            value=self.input, on_change=self.input_changed\n                        ).props(\"size=100\")\n                    with ui.row() as self.button_row:\n                        self.tool_button(\n                            tooltip=\"reload\",\n                            icon=\"refresh\",\n                            handler=self.reload_file,\n                        )\n                        self.assessment_button = self.tool_button(\n                            tooltip=\"assessment\",\n                            icon=\"query_stats\",\n                            handler=self.new_assess,\n                        )\n                        if self.is_local:\n                            self.tool_button(\n                                tooltip=\"open\",\n                                icon=\"file_open\",\n                                handler=self.open_file,\n                            )\n                        self.download_button = self.tool_button(\n                            tooltip=\"download\",\n                            icon=\"download\",\n                            handler=self.download,\n                        )\n            with splitter.after:\n                self.svg_view = ui.html(\"\")\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer","title":"<code>DynamicCompentenceMapWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>server to supply Dynamic Competence Map Visualizations</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>class DynamicCompentenceMapWebServer(InputWebserver):\n    \"\"\"\n    server to supply Dynamic Competence Map Visualizations\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        \"\"\"\n        get the configuration for this Webserver\n        \"\"\"\n        copy_right = \"\"\n        config = WebserverConfig(\n            short_name=\"dcm\",\n            copy_right=copy_right,\n            version=Version(),\n            default_port=8885,\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = DcmSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(\n            self, config=DynamicCompentenceMapWebServer.get_config()\n        )\n        self.examples = DynamicCompetenceMap.get_examples(markup=\"yaml\")\n\n        # FastAPI endpoints\n        @app.post(\"/svg/\")\n        async def render_svg(svg_render_request: SVGRenderRequest) -&gt; HTMLResponse:\n            \"\"\"\n            render the given request\n            \"\"\"\n            return await self.render_svg(svg_render_request)\n\n        @app.get(\"/description/{tree_id}/{aspect_id}/{area_id}/{facet_id}\")\n        async def get_description_for_facet(\n            tree_id: str,\n            aspect_id: str = None,\n            area_id: str = None,\n            facet_id: str = None,\n        ) -&gt; HTMLResponse:\n            \"\"\"\n            Endpoints to get the description of a competence facet\n\n\n            Args:\n                tree_id (str): ID of the tree\n                area_id (str): ID of the area\n                aspect_id (str, optional): ID of the aspect. Defaults to None.\n                facet_id (str, optional): ID of the facet. Defaults to None.\n\n            Returns:\n                HTMLResponse: HTML content of the description.\n            \"\"\"\n            path = f\"{tree_id}/{aspect_id}/{area_id}/{facet_id}\"\n            return await self.show_description(path)\n\n        @app.get(\"/description/{tree_id}/{aspect_id}/{area_id}\")\n        async def get_description_for_area(\n            tree_id: str, aspect_id: str = None, area_id: str = None\n        ) -&gt; HTMLResponse:\n            \"\"\"\n            Endpoints to get the description of a\n            competence area\n\n            Args:\n                tree_id (str): ID of the tree\n                area_id (str): ID of the area\n                aspect_id (str, optional): ID of the aspect. Defaults to None.\n\n            Returns:\n                HTMLResponse: HTML content of the description.\n            \"\"\"\n            path = f\"{tree_id}/{aspect_id}/{area_id}\"\n            return await self.show_description(path)\n\n        @app.get(\"/description/{tree_id}/{aspect_id}\")\n        async def get_description_for_aspect(\n            tree_id: str, aspect_id: str = None\n        ) -&gt; HTMLResponse:\n            \"\"\"\n            Endpoint to get the description of a competence aspect\n\n            Args:\n                tree_id (str): ID of the tree\n                area_id (str): ID of the area\n\n            Returns:\n                HTMLResponse: HTML content of the description.\n            \"\"\"\n            path = f\"{tree_id}/{aspect_id}\"\n            return await self.show_description(path)\n\n        @app.get(\"/description/{tree_id}\")\n        async def get_description_for_tree(tree_id: str) -&gt; HTMLResponse:\n            \"\"\"\n            Endpoint to get the description of a competence tree\n\n            Args:\n                tree_id (str): ID of the tree\n\n            Returns:\n                HTMLResponse: HTML content of the description.\n            \"\"\"\n            path = f\"{tree_id}\"\n            return await self.show_description(path)\n\n        # nicegui RESTFul endpoints\n        @ui.page(\"/learner/{learner_slug}\")\n        async def show_learner(client: Client, learner_slug: str):\n            return await self.page(\n                client, DcmSolution.assess_learner_by_slug, learner_slug\n            )\n\n    async def render_svg(self, svg_render_request: SVGRenderRequest) -&gt; HTMLResponse:\n        \"\"\"\n        render the given request\n        \"\"\"\n        r = svg_render_request\n        dcm = DynamicCompetenceMap.from_definition_string(\n            r.name, r.definition, content_class=CompetenceTree, markup=r.markup\n        )\n        dcm_chart = DcmChart(dcm)\n        svg_markup = dcm_chart.generate_svg_markup(\n            config=r.config, with_java_script=True, text_mode=r.text_mode\n        )\n        response = HTMLResponse(content=svg_markup)\n        return response\n\n    async def show_description(self, path: str = None) -&gt; HTMLResponse:\n        \"\"\"\n        Show the HTML description of a specific\n        competence element given by the path\n\n        Args:\n            path(str): the path identifying the element\n\n        Returns:\n            HTMLResponse: The response object containing the HTML-formatted description.\n\n        Raises:\n            HTTPException: If the example name provided does not exist in the examples collection.\n        \"\"\"\n        path_parts = path.split(\"/\")\n        tree_id = path_parts[0]\n        if tree_id in self.examples:\n            example = self.examples[tree_id]\n            element = example.competence_tree.lookup_by_path(path)\n            if element:\n                content = element.as_html()\n                return HTMLResponse(content=content)\n            else:\n                content = f\"No element found for {path} in {tree_id}\"\n                return HTMLResponse(content=content, status_code=404)\n        else:\n            msg = f\"unknown competence tree {tree_id}\"\n            raise HTTPException(status_code=404, detail=msg)\n\n    def configure_run(self):\n        \"\"\"\n        configure the allowed urls\n        \"\"\"\n        InputWebserver.configure_run(self)\n        self.allowed_urls = [\n            # \"https://raw.githubusercontent.com/JuanIrache/DJI_SRT_Parser/master/samples/\",\n            # \"https://raw.githubusercontent.com/JuanIrache/dji-srt-viewer/master/samples/\",\n            # \"https://cycle.travel/gpx/\",\n            # \"https://cycle.travel/map/journey/\",\n            DynamicCompetenceMap.examples_path(),\n            self.root_path,\n        ]\n        pass\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(\n        self, config=DynamicCompentenceMapWebServer.get_config()\n    )\n    self.examples = DynamicCompetenceMap.get_examples(markup=\"yaml\")\n\n    # FastAPI endpoints\n    @app.post(\"/svg/\")\n    async def render_svg(svg_render_request: SVGRenderRequest) -&gt; HTMLResponse:\n        \"\"\"\n        render the given request\n        \"\"\"\n        return await self.render_svg(svg_render_request)\n\n    @app.get(\"/description/{tree_id}/{aspect_id}/{area_id}/{facet_id}\")\n    async def get_description_for_facet(\n        tree_id: str,\n        aspect_id: str = None,\n        area_id: str = None,\n        facet_id: str = None,\n    ) -&gt; HTMLResponse:\n        \"\"\"\n        Endpoints to get the description of a competence facet\n\n\n        Args:\n            tree_id (str): ID of the tree\n            area_id (str): ID of the area\n            aspect_id (str, optional): ID of the aspect. Defaults to None.\n            facet_id (str, optional): ID of the facet. Defaults to None.\n\n        Returns:\n            HTMLResponse: HTML content of the description.\n        \"\"\"\n        path = f\"{tree_id}/{aspect_id}/{area_id}/{facet_id}\"\n        return await self.show_description(path)\n\n    @app.get(\"/description/{tree_id}/{aspect_id}/{area_id}\")\n    async def get_description_for_area(\n        tree_id: str, aspect_id: str = None, area_id: str = None\n    ) -&gt; HTMLResponse:\n        \"\"\"\n        Endpoints to get the description of a\n        competence area\n\n        Args:\n            tree_id (str): ID of the tree\n            area_id (str): ID of the area\n            aspect_id (str, optional): ID of the aspect. Defaults to None.\n\n        Returns:\n            HTMLResponse: HTML content of the description.\n        \"\"\"\n        path = f\"{tree_id}/{aspect_id}/{area_id}\"\n        return await self.show_description(path)\n\n    @app.get(\"/description/{tree_id}/{aspect_id}\")\n    async def get_description_for_aspect(\n        tree_id: str, aspect_id: str = None\n    ) -&gt; HTMLResponse:\n        \"\"\"\n        Endpoint to get the description of a competence aspect\n\n        Args:\n            tree_id (str): ID of the tree\n            area_id (str): ID of the area\n\n        Returns:\n            HTMLResponse: HTML content of the description.\n        \"\"\"\n        path = f\"{tree_id}/{aspect_id}\"\n        return await self.show_description(path)\n\n    @app.get(\"/description/{tree_id}\")\n    async def get_description_for_tree(tree_id: str) -&gt; HTMLResponse:\n        \"\"\"\n        Endpoint to get the description of a competence tree\n\n        Args:\n            tree_id (str): ID of the tree\n\n        Returns:\n            HTMLResponse: HTML content of the description.\n        \"\"\"\n        path = f\"{tree_id}\"\n        return await self.show_description(path)\n\n    # nicegui RESTFul endpoints\n    @ui.page(\"/learner/{learner_slug}\")\n    async def show_learner(client: Client, learner_slug: str):\n        return await self.page(\n            client, DcmSolution.assess_learner_by_slug, learner_slug\n        )\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer.configure_run","title":"<code>configure_run()</code>","text":"<p>configure the allowed urls</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>def configure_run(self):\n    \"\"\"\n    configure the allowed urls\n    \"\"\"\n    InputWebserver.configure_run(self)\n    self.allowed_urls = [\n        # \"https://raw.githubusercontent.com/JuanIrache/DJI_SRT_Parser/master/samples/\",\n        # \"https://raw.githubusercontent.com/JuanIrache/dji-srt-viewer/master/samples/\",\n        # \"https://cycle.travel/gpx/\",\n        # \"https://cycle.travel/map/journey/\",\n        DynamicCompetenceMap.examples_path(),\n        self.root_path,\n    ]\n    pass\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer.get_config","title":"<code>get_config()</code>  <code>classmethod</code>","text":"<p>get the configuration for this Webserver</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>@classmethod\ndef get_config(cls) -&gt; WebserverConfig:\n    \"\"\"\n    get the configuration for this Webserver\n    \"\"\"\n    copy_right = \"\"\n    config = WebserverConfig(\n        short_name=\"dcm\",\n        copy_right=copy_right,\n        version=Version(),\n        default_port=8885,\n    )\n    server_config = WebserverConfig.get(config)\n    server_config.solution_class = DcmSolution\n    return server_config\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer.render_svg","title":"<code>render_svg(svg_render_request)</code>  <code>async</code>","text":"<p>render the given request</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def render_svg(self, svg_render_request: SVGRenderRequest) -&gt; HTMLResponse:\n    \"\"\"\n    render the given request\n    \"\"\"\n    r = svg_render_request\n    dcm = DynamicCompetenceMap.from_definition_string(\n        r.name, r.definition, content_class=CompetenceTree, markup=r.markup\n    )\n    dcm_chart = DcmChart(dcm)\n    svg_markup = dcm_chart.generate_svg_markup(\n        config=r.config, with_java_script=True, text_mode=r.text_mode\n    )\n    response = HTMLResponse(content=svg_markup)\n    return response\n</code></pre>"},{"location":"#dcm.dcm_webserver.DynamicCompentenceMapWebServer.show_description","title":"<code>show_description(path=None)</code>  <code>async</code>","text":"<p>Show the HTML description of a specific competence element given by the path</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path identifying the element</p> required <p>Returns:</p> Name Type Description <code>HTMLResponse</code> <code>HTMLResponse</code> <p>The response object containing the HTML-formatted description.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the example name provided does not exist in the examples collection.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>async def show_description(self, path: str = None) -&gt; HTMLResponse:\n    \"\"\"\n    Show the HTML description of a specific\n    competence element given by the path\n\n    Args:\n        path(str): the path identifying the element\n\n    Returns:\n        HTMLResponse: The response object containing the HTML-formatted description.\n\n    Raises:\n        HTTPException: If the example name provided does not exist in the examples collection.\n    \"\"\"\n    path_parts = path.split(\"/\")\n    tree_id = path_parts[0]\n    if tree_id in self.examples:\n        example = self.examples[tree_id]\n        element = example.competence_tree.lookup_by_path(path)\n        if element:\n            content = element.as_html()\n            return HTMLResponse(content=content)\n        else:\n            content = f\"No element found for {path} in {tree_id}\"\n            return HTMLResponse(content=content, status_code=404)\n    else:\n        msg = f\"unknown competence tree {tree_id}\"\n        raise HTTPException(status_code=404, detail=msg)\n</code></pre>"},{"location":"#dcm.dcm_webserver.SVGRenderRequest","title":"<code>SVGRenderRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A request for rendering an SVG.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the render request.</p> <code>definition</code> <code>str</code> <p>The string representation of the data to be rendered, in either JSON or YAML format.</p> <code>markup</code> <code>str</code> <p>The format of the definition ('json' or 'yaml').</p> <code>config</code> <code>SVGConfig</code> <p>Optional configuration for SVG rendering. Defaults to None, which uses default settings.</p> Source code in <code>dcm/dcm_webserver.py</code> <pre><code>class SVGRenderRequest(BaseModel):\n    \"\"\"\n    A request for rendering an SVG.\n\n    Attributes:\n        name (str): The name of the render request.\n        definition (str): The string representation of the data to be rendered, in either JSON or YAML format.\n        markup (str): The format of the definition ('json' or 'yaml').\n        config (SVGConfig): Optional configuration for SVG rendering. Defaults to None, which uses default settings.\n    \"\"\"\n\n    name: str\n    definition: str\n    markup: str\n    text_mode: Optional[str] = \"empty\"\n    config: Optional[SVGConfig] = None\n</code></pre>"},{"location":"#dcm.linkml","title":"<code>linkml</code>","text":""},{"location":"#dcm.linkml.dcm_model","title":"<code>dcm_model</code>","text":""},{"location":"#dcm.linkml.dcm_model.Achievement","title":"<code>Achievement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>YAMLRoot</code></p> <p>A record of an achievement attained by a learner.</p> Source code in <code>dcm/linkml/dcm_model.py</code> <pre><code>@dataclass\nclass Achievement(YAMLRoot):\n    \"\"\"\n    A record of an achievement attained by a learner.\n    \"\"\"\n    _inherited_slots: ClassVar[List[str]] = []\n\n    class_class_uri: ClassVar[URIRef] = DCM.Achievement\n    class_class_curie: ClassVar[str] = \"dcm:Achievement\"\n    class_name: ClassVar[str] = \"Achievement\"\n    class_model_uri: ClassVar[URIRef] = DCM.Achievement\n\n    path: Optional[str] = None\n    level: Optional[int] = None\n    score: Optional[float] = None\n    date_assessed_iso: Optional[str] = None\n\n    def __post_init__(self, *_: List[str], **kwargs: Dict[str, Any]):\n        if self.path is not None and not isinstance(self.path, str):\n            self.path = str(self.path)\n\n        if self.level is not None and not isinstance(self.level, int):\n            self.level = int(self.level)\n\n        if self.score is not None and not isinstance(self.score, float):\n            self.score = float(self.score)\n\n        if self.date_assessed_iso is not None and not isinstance(self.date_assessed_iso, str):\n            self.date_assessed_iso = str(self.date_assessed_iso)\n\n        super().__post_init__(**kwargs)\n</code></pre>"},{"location":"#dcm.linkml.dcm_model.Learner","title":"<code>Learner</code>  <code>dataclass</code>","text":"<p>               Bases: <code>YAMLRoot</code></p> <p>An individual learner with a unique identifier and a list of achievements.</p> Source code in <code>dcm/linkml/dcm_model.py</code> <pre><code>@dataclass\nclass Learner(YAMLRoot):\n    \"\"\"\n    An individual learner with a unique identifier and a list of achievements.\n    \"\"\"\n    _inherited_slots: ClassVar[List[str]] = []\n\n    class_class_uri: ClassVar[URIRef] = DCM.Learner\n    class_class_curie: ClassVar[str] = \"dcm:Learner\"\n    class_name: ClassVar[str] = \"Learner\"\n    class_model_uri: ClassVar[URIRef] = DCM.Learner\n\n    learner_id: Optional[str] = None\n    achievements: Optional[Union[Union[dict, \"Achievement\"], List[Union[dict, \"Achievement\"]]]] = empty_list()\n\n    def __post_init__(self, *_: List[str], **kwargs: Dict[str, Any]):\n        if self.learner_id is not None and not isinstance(self.learner_id, str):\n            self.learner_id = str(self.learner_id)\n\n        if not isinstance(self.achievements, list):\n            self.achievements = [self.achievements] if self.achievements is not None else []\n        self.achievements = [v if isinstance(v, Achievement) else Achievement(**as_dict(v)) for v in self.achievements]\n\n        super().__post_init__(**kwargs)\n</code></pre>"},{"location":"#dcm.radar_chart","title":"<code>radar_chart</code>","text":"<p>Created on 2024-02-05</p> <p>@author: wf</p>"},{"location":"#dcm.radar_chart.RadarChart","title":"<code>RadarChart</code>","text":"<p>a radar chart</p> Source code in <code>dcm/radar_chart.py</code> <pre><code>class RadarChart:\n    \"\"\"\n    a radar chart\n    \"\"\"\n\n    def __init__(self, svg: SVG, max_score: float = 100.0):\n        self.svg = svg\n        self.radius = self.svg.config.width / 2\n        self.center_x = self.radius\n        self.center_y = self.radius\n        self.max_score = max_score\n\n    def add_scale_circles(\n        self,\n        num_circles: int = 10,\n        stroke_width: float = 1.0,\n        stroke_color: str = \"black\",\n    ):\n        \"\"\"\n        Add concentric circles to the SVG based on the SVG's configuration.\n\n        Args:\n            num_circles (int): The number of concentric circles to draw.\n            stroke_width (float): The stroke width of the circle lines.\n            stroke_color (str): The color of the circle lines.\n        \"\"\"\n        for i in range(1, num_circles + 1):\n            circle_radius = (self.radius * i) / num_circles\n            self.svg.add_circle(\n                SVGNodeConfig(\n                    x=self.center_x,\n                    y=self.center_y,\n                    width=circle_radius,\n                    stroke_width=stroke_width,\n                    color=stroke_color,\n                    fill=\"none\",  # Ensure circles are not filled\n                )\n            )\n\n    def calculate_radar_chart_points(\n        self, scores: List[float]\n    ) -&gt; List[Tuple[float, float]]:\n        \"\"\"\n        Calculate the points for the radar chart based on the given scores.\n\n        Args:\n            scores (List[float]): The scores to be represented on the radar chart.\n\n        Returns:\n            List[Tuple[float, float]]: The list of points for the radar chart.\n        \"\"\"\n        num_axes = len(scores)\n        angle_per_axis = 2 * math.pi / num_axes  # Angle between each axis in radians\n\n        points = []\n        for i, score in enumerate(scores):\n            angle = angle_per_axis * i  # Angle for this axis\n            # Calculate the distance from the center for this point\n            distance = (score / self.max_score) * self.radius\n            x = self.center_x + distance * math.cos(angle)\n            y = self.center_y + distance * math.sin(angle)\n            points.append((x, y))\n\n        return points\n\n    def add_scores(\n        self, scores: List[float], config: Optional[SVGNodeConfig] = None\n    ) -&gt; None:\n        \"\"\"\n        Add the scores to the radar chart as a polygon.\n\n        Args:\n            scores (List[float]): The scores to be represented on the radar chart.\n            config (SVGNodeConfig, optional): The configuration for the polygon representing the scores.\n        \"\"\"  # Use the function to calculate points for the scores\n        radar_points = self.calculate_radar_chart_points(scores)\n        if config is None:\n            config = SVGNodeConfig(\n                color=\"blue\", fill=\"none\", stroke_width=2.0, opacity=0.5\n            )\n\n        # Create a Polygon for the radar chart\n        radar_chart_polygon = Polygon(\n            points=radar_points,\n            fill=config.fill,\n            stroke_width=config.stroke_width,\n            color=config.color,\n            opacity=config.opacity,\n        )\n        self.svg.add_polygon(radar_chart_polygon)\n</code></pre>"},{"location":"#dcm.radar_chart.RadarChart.add_scale_circles","title":"<code>add_scale_circles(num_circles=10, stroke_width=1.0, stroke_color='black')</code>","text":"<p>Add concentric circles to the SVG based on the SVG's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>num_circles</code> <code>int</code> <p>The number of concentric circles to draw.</p> <code>10</code> <code>stroke_width</code> <code>float</code> <p>The stroke width of the circle lines.</p> <code>1.0</code> <code>stroke_color</code> <code>str</code> <p>The color of the circle lines.</p> <code>'black'</code> Source code in <code>dcm/radar_chart.py</code> <pre><code>def add_scale_circles(\n    self,\n    num_circles: int = 10,\n    stroke_width: float = 1.0,\n    stroke_color: str = \"black\",\n):\n    \"\"\"\n    Add concentric circles to the SVG based on the SVG's configuration.\n\n    Args:\n        num_circles (int): The number of concentric circles to draw.\n        stroke_width (float): The stroke width of the circle lines.\n        stroke_color (str): The color of the circle lines.\n    \"\"\"\n    for i in range(1, num_circles + 1):\n        circle_radius = (self.radius * i) / num_circles\n        self.svg.add_circle(\n            SVGNodeConfig(\n                x=self.center_x,\n                y=self.center_y,\n                width=circle_radius,\n                stroke_width=stroke_width,\n                color=stroke_color,\n                fill=\"none\",  # Ensure circles are not filled\n            )\n        )\n</code></pre>"},{"location":"#dcm.radar_chart.RadarChart.add_scores","title":"<code>add_scores(scores, config=None)</code>","text":"<p>Add the scores to the radar chart as a polygon.</p> <p>Parameters:</p> Name Type Description Default <code>scores</code> <code>List[float]</code> <p>The scores to be represented on the radar chart.</p> required <code>config</code> <code>SVGNodeConfig</code> <p>The configuration for the polygon representing the scores.</p> <code>None</code> Source code in <code>dcm/radar_chart.py</code> <pre><code>def add_scores(\n    self, scores: List[float], config: Optional[SVGNodeConfig] = None\n) -&gt; None:\n    \"\"\"\n    Add the scores to the radar chart as a polygon.\n\n    Args:\n        scores (List[float]): The scores to be represented on the radar chart.\n        config (SVGNodeConfig, optional): The configuration for the polygon representing the scores.\n    \"\"\"  # Use the function to calculate points for the scores\n    radar_points = self.calculate_radar_chart_points(scores)\n    if config is None:\n        config = SVGNodeConfig(\n            color=\"blue\", fill=\"none\", stroke_width=2.0, opacity=0.5\n        )\n\n    # Create a Polygon for the radar chart\n    radar_chart_polygon = Polygon(\n        points=radar_points,\n        fill=config.fill,\n        stroke_width=config.stroke_width,\n        color=config.color,\n        opacity=config.opacity,\n    )\n    self.svg.add_polygon(radar_chart_polygon)\n</code></pre>"},{"location":"#dcm.radar_chart.RadarChart.calculate_radar_chart_points","title":"<code>calculate_radar_chart_points(scores)</code>","text":"<p>Calculate the points for the radar chart based on the given scores.</p> <p>Parameters:</p> Name Type Description Default <code>scores</code> <code>List[float]</code> <p>The scores to be represented on the radar chart.</p> required <p>Returns:</p> Type Description <code>List[Tuple[float, float]]</code> <p>List[Tuple[float, float]]: The list of points for the radar chart.</p> Source code in <code>dcm/radar_chart.py</code> <pre><code>def calculate_radar_chart_points(\n    self, scores: List[float]\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"\n    Calculate the points for the radar chart based on the given scores.\n\n    Args:\n        scores (List[float]): The scores to be represented on the radar chart.\n\n    Returns:\n        List[Tuple[float, float]]: The list of points for the radar chart.\n    \"\"\"\n    num_axes = len(scores)\n    angle_per_axis = 2 * math.pi / num_axes  # Angle between each axis in radians\n\n    points = []\n    for i, score in enumerate(scores):\n        angle = angle_per_axis * i  # Angle for this axis\n        # Calculate the distance from the center for this point\n        distance = (score / self.max_score) * self.radius\n        x = self.center_x + distance * math.cos(angle)\n        y = self.center_y + distance * math.sin(angle)\n        points.append((x, y))\n\n    return points\n</code></pre>"},{"location":"#dcm.svg","title":"<code>svg</code>","text":""},{"location":"#dcm.svg.DonutSegment","title":"<code>DonutSegment</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SVGNode</code></p> <p>A donut segment representing a section of a donut chart.</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass DonutSegment(SVGNode):\n    \"\"\"\n    A donut segment representing a\n    section of a donut chart.\n    \"\"\"\n\n    cx: float = 0.0\n    cy: float = 0.0\n    inner_radius: float = 0.0\n    outer_radius: float = 0.0\n    start_angle: Optional[float] = 0.0\n    end_angle: Optional[float] = 360.0\n    text_mode: Optional[str] = None\n\n    @property\n    def large_arc_flag(self) -&gt; str:\n        \"\"\"\n        Determine if the arc should be drawn as a large-arc (values &gt;= 180 degrees).\n\n        Returns:\n            str: \"1\" if the arc is a large arc, otherwise \"0\".\n        \"\"\"\n        large_arc_flag = \"1\" if self.end_angle - self.start_angle &gt;= 180 else \"0\"\n        return large_arc_flag\n\n    def relative_angle(self, angle_factor=0.5) -&gt; float:\n        \"\"\"Calculate a relative angle of the donut segment.\"\"\"\n        relative_angle = (self.start_angle + self.end_angle) * angle_factor\n        return relative_angle\n\n    def radial_radius(self, radial_offset: float) -&gt; float:\n        \"\"\"\n        get the radial radius for the given radial offset\n        \"\"\"\n        radial_radius = (\n            self.inner_radius + (self.outer_radius - self.inner_radius) * radial_offset\n        )\n        return radial_radius\n\n    def x_y(self, angle: float, radial_radius: float):\n        x = self.cx + radial_radius * math.cos(math.radians(angle))\n        y = self.cy + radial_radius * math.sin(math.radians(angle))\n        return x, y\n\n    def get_arc(self, radial_offset: float = 0.5) -&gt; Arc:\n        \"\"\"\n        Get the Arc for the given radial offset\n\n        Args:\n            radial_offset(float): e.g. 0.0 - inner 1.0 outer 0.5 middle\n        Returns:\n            Arc: the arc at the given radial offset\n        \"\"\"\n        # Calculate the adjusted radius within the bounds of inner and outer radii\n        radial_radius = self.radial_radius(radial_offset)\n\n        # Calculate the start and end points of the arc\n        start_x, start_y = self.x_y(self.start_angle, radial_radius)\n        end_x, end_y = self.x_y(self.end_angle, radial_radius)\n        middle_angle = self.relative_angle(0.5)\n        middle_x, middle_y = self.x_y(middle_angle, radial_radius)\n\n        return Arc(\n            radius=radial_radius,\n            start_x=start_x,\n            start_y=start_y,\n            middle_x=middle_x,\n            middle_y=middle_y,\n            end_x=end_x,\n            end_y=end_y,\n        )\n</code></pre>"},{"location":"#dcm.svg.DonutSegment.large_arc_flag","title":"<code>large_arc_flag: str</code>  <code>property</code>","text":"<p>Determine if the arc should be drawn as a large-arc (values &gt;= 180 degrees).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"1\" if the arc is a large arc, otherwise \"0\".</p>"},{"location":"#dcm.svg.DonutSegment.get_arc","title":"<code>get_arc(radial_offset=0.5)</code>","text":"<p>Get the Arc for the given radial offset</p> <p>Parameters:</p> Name Type Description Default <code>radial_offset(float)</code> <p>e.g. 0.0 - inner 1.0 outer 0.5 middle</p> required <p>Returns:     Arc: the arc at the given radial offset</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_arc(self, radial_offset: float = 0.5) -&gt; Arc:\n    \"\"\"\n    Get the Arc for the given radial offset\n\n    Args:\n        radial_offset(float): e.g. 0.0 - inner 1.0 outer 0.5 middle\n    Returns:\n        Arc: the arc at the given radial offset\n    \"\"\"\n    # Calculate the adjusted radius within the bounds of inner and outer radii\n    radial_radius = self.radial_radius(radial_offset)\n\n    # Calculate the start and end points of the arc\n    start_x, start_y = self.x_y(self.start_angle, radial_radius)\n    end_x, end_y = self.x_y(self.end_angle, radial_radius)\n    middle_angle = self.relative_angle(0.5)\n    middle_x, middle_y = self.x_y(middle_angle, radial_radius)\n\n    return Arc(\n        radius=radial_radius,\n        start_x=start_x,\n        start_y=start_y,\n        middle_x=middle_x,\n        middle_y=middle_y,\n        end_x=end_x,\n        end_y=end_y,\n    )\n</code></pre>"},{"location":"#dcm.svg.DonutSegment.radial_radius","title":"<code>radial_radius(radial_offset)</code>","text":"<p>get the radial radius for the given radial offset</p> Source code in <code>dcm/svg.py</code> <pre><code>def radial_radius(self, radial_offset: float) -&gt; float:\n    \"\"\"\n    get the radial radius for the given radial offset\n    \"\"\"\n    radial_radius = (\n        self.inner_radius + (self.outer_radius - self.inner_radius) * radial_offset\n    )\n    return radial_radius\n</code></pre>"},{"location":"#dcm.svg.DonutSegment.relative_angle","title":"<code>relative_angle(angle_factor=0.5)</code>","text":"<p>Calculate a relative angle of the donut segment.</p> Source code in <code>dcm/svg.py</code> <pre><code>def relative_angle(self, angle_factor=0.5) -&gt; float:\n    \"\"\"Calculate a relative angle of the donut segment.\"\"\"\n    relative_angle = (self.start_angle + self.end_angle) * angle_factor\n    return relative_angle\n</code></pre>"},{"location":"#dcm.svg.Polygon","title":"<code>Polygon</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SVGNode</code></p> <p>A polygon representing a series of data points in a radar chart.</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass Polygon(SVGNode):\n    \"\"\"\n    A polygon representing a series of data points in a radar chart.\n    \"\"\"\n\n    # List of points (x, y) forming the polygon\n    points: List[Tuple[float, float]] = field(default_factory=list)\n</code></pre>"},{"location":"#dcm.svg.SVG","title":"<code>SVG</code>","text":"<p>Class for creating SVG drawings.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>SVGConfig</code> <p>Configuration for the SVG drawing.</p> Source code in <code>dcm/svg.py</code> <pre><code>class SVG:\n    \"\"\"\n    Class for creating SVG drawings.\n\n    Attributes:\n        config (SVGConfig): Configuration for the SVG drawing.\n    \"\"\"\n\n    def __init__(self, config: SVGConfig = None):\n        \"\"\"\n        Initialize SVG object with given configuration.\n\n        Args:\n            config (SVGConfig): Configuration for SVG generation.\n        \"\"\"\n        self.config = config if config else SVGConfig()\n        self.width = self.config.width\n        self.height = self.config.height\n        self.elements = []\n        self.indent = self.config.indent\n\n    def get_indent(self, level) -&gt; str:\n        \"\"\"\n        get the indentation for the given level\n        \"\"\"\n        indentation = f\"{self.indent * level}\"\n        return indentation\n\n    def get_svg_style(self) -&gt; str:\n        \"\"\"\n        Define styles for SVG elements.\n\n        Returns:\n            str: String containing style definitions for SVG.\n        \"\"\"\n        style = (\n            f\"{self.indent}&lt;style&gt;\\n\"\n            f\"{self.indent * 2}.hoverable {{ cursor: pointer; fill-opacity: 1; stroke: black; stroke-width: 0.5; }}\\n\"\n            f\"{self.indent * 2}.hoverable:hover {{ fill-opacity: 0.7; }}\\n\"\n            f\"{self.indent * 2}.selected {{ fill-opacity: 0.5; stroke: blue !important; stroke-width: 1.5;}}\\n\"\n            f\"{self.indent * 2}.noclick {{ pointer-events: none; }}\\n\"  # style for non-clickable text\n        )\n\n        if self.config.with_popup:\n            style += (\n                f\"{self.indent * 2}.popup {{\\n\"\n                f\"{self.indent * 3}border: 2px solid black;\\n\"\n                f\"{self.indent * 3}border-radius: 15px;\\n\"\n                f\"{self.indent * 3}overflow: auto;\\n\"  # changed to 'auto' to allow scrolling only if needed\n                f\"{self.indent * 3}background: white;\\n\"\n                f\"{self.indent * 3}box-sizing: border-box;\\n\"  # ensures padding and border are included\n                f\"{self.indent * 3}padding: 10px;\\n\"  # optional padding inside the popup\n                f\"{self.indent * 3}height: 100%;\\n\"  # adjusts height relative to foreignObject\n                f\"{self.indent * 3}width: 100%;\\n\"  # adjusts width relative to foreignObject\n                f\"{self.indent * 2}}}\\n\"\n                f\"{self.indent * 2}.close-btn {{\\n\"  # style for the close button\n                f\"{self.indent * 3}cursor: pointer;\\n\"\n                f\"{self.indent * 3}position: absolute;\\n\"\n                f\"{self.indent * 3}top: 0;\\n\"\n                f\"{self.indent * 3}right: 0;\\n\"\n                f\"{self.indent * 3}padding: 5px;\\n\"\n                f\"{self.indent * 3}font-size: 20px;\\n\"\n                f\"{self.indent * 3}user-select: none;\\n\"  # prevents text selection on click\n                f\"{self.indent * 2}}}\\n\"\n            )\n\n        style += f\"{self.indent}&lt;/style&gt;\\n\"\n        return style\n\n    def get_text_width(self, text: str) -&gt; int:\n        \"\"\"\n        Estimate the width of a text string in the SVG based on the font size and font name.\n\n        Args:\n            text (str): The text content.\n\n        Returns:\n            int: The estimated width of the text in pixels.\n        \"\"\"\n        average_char_width_factor = 0.6\n        average_char_width = average_char_width_factor * self.config.font_size\n        return int(average_char_width * len(text))\n\n    def get_text_rotation(self, rotation_angle: float) -&gt; float:\n        \"\"\"\n        Adjusts the rotation angle for SVG text elements to ensure that the text\n        is upright and readable in a circular chart. The text will be rotated\n        by 180 degrees if it is in the lower half of the chart (between 90 and 270 degrees).\n\n        Args:\n            rotation_angle (float): The initial rotation angle of the text element.\n\n        Returns:\n            float: The adjusted rotation angle for the text element.\n        \"\"\"\n        # In the bottom half of the chart (90 to 270 degrees), the text\n        # would appear upside down, so we rotate it by 180 degrees.\n        if 90 &lt;= rotation_angle &lt; 270:\n            rotation_angle -= 180\n\n        # Return the adjusted angle. No adjustment is needed for the\n        # top half of the chart as the text is already upright.\n        return rotation_angle\n\n    def get_donut_path(\n        self,\n        segment: DonutSegment,\n        radial_offset: float = 0.5,\n        middle_arc: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Create an SVG path definition for an arc using the properties of a DonutSegment.\n\n        Args:\n            segment (DonutSegment): The segment for which to create the path.\n            radial_offset(float): 0 to 1 - useable in middle_arc mode\n            middle_arc(bool): if True get the middle arc\n\n        Returns:\n            str: SVG path definition string for the full donut segment or the middle_arc if middle_arc is set to true.\n        \"\"\"\n        if middle_arc:\n            arc = segment.get_arc(radial_offset=radial_offset)\n\n            # Create the path for the middle arc\n            path_str = (\n                f\"M {arc.start_x} {arc.start_y} \"  # Move to start of middle arc\n                f\"A {arc.radius} {arc.radius} 0 {segment.large_arc_flag} 1 {arc.end_x} {arc.end_y}\"\n            )\n        else:\n            outer_arc = segment.get_arc(radial_offset=1)\n            inner_arc = segment.get_arc(radial_offset=0)\n            path_str = (\n                f\"M {inner_arc.start_x} {inner_arc.start_y} \"  # Move to start of inner arc\n                f\"L {outer_arc.start_x} {outer_arc.start_y} \"  # Line to start of outer arc\n                f\"A {segment.outer_radius} {segment.outer_radius} 0 {segment.large_arc_flag} 1 {outer_arc.end_x} {outer_arc.end_y} \"  # Outer arc\n                f\"L {inner_arc.end_x} {inner_arc.end_y} \"  # Line to end of inner arc\n                f\"A {segment.inner_radius} {segment.inner_radius} 0 {segment.large_arc_flag} 0 {inner_arc.start_x} {inner_arc.start_y} \"  # Inner arc (reverse)\n                \"Z\"\n            )\n\n        return path_str\n\n    def add_element(self, element: str, indent_level: int = 1, comment: str = None):\n        \"\"\"\n        Add an SVG element to the elements list with proper indentation.\n\n        Args:\n            element (str): SVG element to be added.\n            indent_level (int): Indentation level for the element.\n            comment(str): optional comment to add\n        \"\"\"\n        base_indent = self.get_indent(indent_level)\n        if comment:\n            indented_comment = f\"{base_indent}&lt;!-- {comment} --&gt;\\n\"\n            self.elements.append(indented_comment)\n        indented_element = f\"{base_indent}{element}\\n\"\n        self.elements.append(indented_element)\n\n    def add_circle(self, config: SVGNodeConfig):\n        \"\"\"\n        Add a circle element to the SVG, optionally making it clickable and with a hover effect.\n\n        Args:\n            config (SVGNodeConfig): Configuration for the circle element.\n        \"\"\"\n        color = config.fill if config.fill else self.config.default_color\n        circle_element = f'&lt;circle cx=\"{config.x}\" cy=\"{config.y}\" r=\"{config.width}\" fill=\"{color}\" class=\"{config.element_class}\" /&gt;'\n\n        # If URL is provided, wrap the circle in an anchor tag to make it clickable\n        if config.url:\n            circle_indent = self.get_indent(config.indent_level + 1)\n            circle_element = f\"\"\"&lt;a xlink:href=\"{config.url}\" target=\"_blank\"&gt;\n{circle_indent}{circle_element}\n&lt;/a&gt;\"\"\"\n\n        # Use add_group to add the circle element with proper indentation\n        self.add_group(\n            circle_element,\n            group_id=config.id,\n            group_class=config.element_class,\n            indent_level=config.indent_level,\n            comment=config.comment,\n        )\n\n    def add_rectangle(\n        self,\n        x: int,\n        y: int,\n        width: int,\n        height: int,\n        fill: str = None,\n        indent_level: int = 1,\n    ):\n        \"\"\"\n        Add a rectangle element to the SVG.\n\n        Args:\n            x (int): X-coordinate of the rectangle's top-left corner.\n            y (int): Y-coordinate of the rectangle's top-left corner.\n            width (int): Width of the rectangle.\n            height (int): Height of the rectangle.\n            fill (str, optional): Fill color of the rectangle. Defaults to the default color.\n            indent_level (int): Indentation level for the rectangle.\n        \"\"\"\n        color = fill if fill else self.config.default_color\n        rect = f'&lt;rect x=\"{x}\" y=\"{y}\" width=\"{width}\" height=\"{height}\" fill=\"{color}\" /&gt;\\n'\n        self.add_element(rect, indent_level=indent_level)\n\n    def add_polygon(self, polygon: Polygon, indent_level: int = 1):\n        \"\"\"\n        Add a polygon to the SVG.\n\n        Args:\n            polygon (Polygon): The polygon to add to the SVG.\n            indent_level (int): Indentation level for the element.\n        \"\"\"\n        points_str = \" \".join(f\"{x},{y}\" for x, y in polygon.points)\n        fill_color = polygon.fill if polygon.fill else self.config.default_color\n        opacity = polygon.opacity\n        stroke_color = polygon.color if polygon.color else \"black\"\n        stroke_width = polygon.stroke_width\n\n        polygon_element = (\n            f'&lt;polygon points=\"{points_str}\" '\n            f'stroke=\"{stroke_color}\" stroke-width=\"{stroke_width}\" '\n            f'fill=\"{fill_color}\" fill-opacity=\"{opacity}\" /&gt;\\n'\n        )\n\n        # If a title (tooltip) is provided, create a title element\n        title_element = (\n            f\"&lt;title&gt;{html.escape(polygon.title)}&lt;/title&gt;\\n\" if polygon.title else \"\"\n        )\n\n        # Combine polygon and title into one string without adding indentation here\n        group_content = f\"{polygon_element}{title_element}\"\n\n        # Use add_group to add the polygon with proper indentation and optional comment\n        self.add_group(\n            group_content,\n            group_id=polygon.id,\n            group_class=\"hoverable\",  # You might want to adjust this or make it configurable\n            indent_level=indent_level,\n            comment=polygon.comment,\n        )\n\n    def add_legend_column(\n        self,\n        items: List[Tuple[str, str]],\n        title: str,\n        x: int,\n        y: int,\n        width: int,\n        height: int,\n    ) -&gt; None:\n        \"\"\"\n        Add a legend column to the SVG.\n\n        Args:\n            items (List[Tuple[str, str]]): List of tuples with color code and label.\n            title (str): Title of the legend.\n            x (int): X position of the legend.\n            y (int): Y position of the legend.\n            width (int): Width of the color box in the legend.\n            height (int): Height of each legend item.\n        \"\"\"\n        self.add_text(x, y - height, title, font_weight=\"bold\")\n        for index, (color, label) in enumerate(items):\n            self.add_rectangle(x, y + index * (height + 5), width, height, color)\n            self.add_text(\n                x + width + 10,\n                y + index * (height + 5) + height / 2,\n                label,\n                center_v=True,\n            )\n\n    def add_text(\n        self,\n        x: int,\n        y: int,\n        text: str,\n        fill: str = \"black\",\n        font_weight: str = \"normal\",\n        text_anchor: str = \"start\",\n        transform: str = \"\",\n        center_v: bool = False,\n        text_class: str = \"noclick\",\n        indent_level: int = 1,\n    ) -&gt; None:\n        \"\"\"\n        Add text to the SVG.\n\n        Args:\n            x (int): X position of the text.\n            y (int): Y position of the text.\n            text(str): Text content.\n            fill (str, optional): Fill color of the text. Defaults to \"black\".\n            font_weight (str, optional): Font weight (normal, bold, etc.). Defaults to \"normal\".\n            text_anchor (str, optional): Text alignment (start, middle, end). Defaults to \"start\".\n            indent_level(int): the indentation level to apply\n            center_v (bool): If True, y as the vertical center of the text. Default is False.\n            text_class(str): \"noclick\" by default so that elements below are clickable\n            transform (str, optional): Transformation for the text (e.g., rotation). Defaults to an empty string.\n        \"\"\"\n        text_obj = Text(text, self.config)\n        if center_v:\n            # y-offset adjustment to center the text vertically\n            y -= text_obj.total_text_height / 2\n            # adjust for the ascender / descender vertical font weighting\n            y -= self.config.font_size * 0.5\n        # Create a text element to hold the tspan elements\n        # Only include the transform attribute if it is provided\n        transform_attr = f'transform=\"{transform}\" ' if transform else \"\"\n\n        text_element = (\n            f'\\n{self.get_indent(indent_level)}&lt;text class=\"{text_class}\" x=\"{x}\" y=\"{y}\" fill=\"{fill}\" '\n            f'font-family=\"{self.config.font}\" '\n            f'font-size=\"{self.config.font_size}\" '\n            f'font-weight=\"{font_weight}\" '\n            f'text-anchor=\"{text_anchor}\" '\n            f'dominant-baseline=\"middle\" '\n            f\"{transform_attr}&gt;\"\n        )\n        # Add tspan elements for each line\n        for line in text_obj.lines:\n            escaped_line = html.escape(line)\n            text_element += f'\\n{self.get_indent(indent_level+1)}&lt;tspan x=\"{x}\" dy=\"{self.config.line_height}\"&gt;{escaped_line}&lt;/tspan&gt;'\n\n        text_element += f\"\\n{self.get_indent(indent_level)}&lt;/text&gt;\\n\"\n        self.add_element(text_element)\n\n    def add_group(\n        self,\n        content: str,\n        group_id: str = None,\n        group_class: str = None,\n        indent_level: int = 1,\n        comment: str = None,\n    ):\n        \"\"\"\n        Add a group of elements to the SVG.\n\n        Args:\n            content (str): SVG content to be grouped.\n            group_id (str, optional): ID for the group.\n            group_class (str, optional): Class for the group.\n            indent_level (int): Indentation level for the group.\n        \"\"\"\n        group_attrs = []\n        if group_id:\n            group_attrs.append(f'id=\"{group_id}\"')\n        if group_class:\n            group_attrs.append(f'class=\"{group_class}\"')\n        attrs_str = \" \".join(group_attrs)\n        indented_content = \"\\n\".join(\n            f\"{self.get_indent(indent_level + 1)}{line}\"\n            for line in content.strip().split(\"\\n\")\n        )\n        group_str = f\"\"\"{self.get_indent(indent_level)}&lt;g {attrs_str}&gt;\n{indented_content}\n{self.get_indent(indent_level)}&lt;/g&gt;\n\"\"\"\n        self.add_element(group_str, indent_level=indent_level, comment=comment)\n\n    def add_donut_segment(\n        self,\n        config: SVGNodeConfig,\n        segment: DonutSegment,\n    ) -&gt; None:\n        \"\"\"\n        Add a donut segment to the SVG.\n\n        Args:\n            config (SVGNodeConfig): Configuration for the donut segment.\n            segment(DonutSegment)\n        \"\"\"\n        color = config.fill if config.fill else self.config.default_color\n        stroke_color = config.color if config.color else \"black\"\n\n        path_str = self.get_donut_path(segment)\n\n        # Assemble the path and title elements\n        path_element = (\n            f'&lt;path d=\"{path_str}\" stroke=\"{stroke_color}\" fill=\"{color}\" /&gt;\\n'\n        )\n        if config.title:\n            escaped_title = html.escape(config.title)  # Escape special characters\n\n            title_element = f\"&lt;title&gt;{escaped_title}&lt;/title&gt;\"\n        else:\n            title_element = \"\"\n        # Combine path and title into one string without adding indentation here\n        group_content = f\"{path_element}{title_element}\"\n\n        # Check if the segment should be shown as a popup\n        if config.show_as_popup:\n            # Add JavaScript to handle popup logic\n            onclick_action = f\"onclick=\\\"showPopup('{config.url}', evt,this)\\\"\"\n            group_content = f\"&lt;g {onclick_action}&gt;{group_content}&lt;/g&gt;\"\n        elif config.url:\n            # Regular link behavior\n            group_content = (\n                f'&lt;a xlink:href=\"{config.url}\" target=\"_blank\"&gt;{group_content}&lt;/a&gt;'\n            )\n\n        # Use add_group to add the pie segment with proper indentation\n        self.add_group(\n            group_content,\n            group_id=config.id,\n            group_class=config.element_class,\n            indent_level=2,\n            comment=config.comment,\n        )\n\n    def add_text_to_donut_segment(\n        self,\n        segment: DonutSegment,\n        text: str,\n        direction: str = \"horizontal\",\n        color: str = \"white\",\n        text_class: str = \"noclick\",\n        indent_level: int = 1,\n    ) -&gt; None:\n        \"\"\"\n        Add text to a donut segment with various direction options.\n\n        Args:\n            segment (DonutSegment): The donut segment to which text will be added.\n            text (str): The text content to be added.\n            direction (str): The direction in which the text should be drawn.\n                             Options are \"horizontal\", \"angled\", or \"curved\".\n            color (str): The color of the text. Default is \"white\".\n        \"\"\"\n        if direction in [\"horizontal\", \"angled\"]:\n            # Calculate position for horizontal or angled text\n            # Use the get_arc method to find the position for horizontal or angled text\n            mid_arc = segment.get_arc(radial_offset=0.5)  # Get the mid-arc\n            text_x, text_y = mid_arc.middle_x, mid_arc.middle_y\n\n            # Adjust text anchor and rotation for better readability\n            transform = \"\"\n            if direction == \"angled\":\n                mid_angle = segment.relative_angle(0.5)\n                rotation_angle = self.get_text_rotation(mid_angle)\n                transform = f\"rotate({rotation_angle}, {text_x}, {text_y})\"\n\n            # Add text using the add_text method\n            self.add_text(\n                x=text_x,\n                y=text_y,\n                text=text,\n                fill=color,\n                font_weight=\"normal\",\n                indent_level=indent_level,\n                transform=transform,\n                text_anchor=\"middle\",\n                center_v=True,\n            )\n\n        elif direction == \"curved\":\n            text_obj = Text(text, self.config)\n\n            for i, line in enumerate(text_obj.lines):\n                radial_offset = 1 - ((i + 1) / (text_obj.line_count + 1))\n                # Create a path for the text to follow\n                path_id = f\"path{segment.start_angle}-{segment.end_angle}-{i}\"\n                path_d = self.get_donut_path(\n                    segment, middle_arc=True, radial_offset=radial_offset\n                )\n                self.add_element(\n                    f'&lt;path id=\"{path_id}\" d=\"{path_d}\" fill=\"none\" stroke=\"none\" /&gt;'\n                )\n\n                text_tag = f\"\"\"&lt;text class=\"{text_class}\" fill=\"{color}\" font-family=\"{self.config.font}\" font-size=\"{self.config.font_size}\"&gt;\"\"\"\n                self.add_element(text_tag, indent_level=indent_level)\n                text_path = f\"\"\"&lt;textPath  xlink:href=\"#{path_id}\" startOffset=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\"&gt;{html.escape(line)}&lt;/textPath&gt;\"\"\"\n                self.add_element(text_path, indent_level=indent_level + 1)\n                self.add_element(\"&lt;/text&gt;\", indent_level=indent_level)\n        else:\n            raise ValueError(f\"invalid direction {direction}\")\n\n    def get_java_script(self) -&gt; str:\n        \"\"\"\n        get the java script code for interactive behavior\n        \"\"\"\n        popup_script = \"\"\"\n    &lt;script&gt;\n         function showPopup(url, evt,element) {\n            // show a Popup fetching html content from the given url\n            // for the given element\n            // Handle the selection of the popup element\n            selectPopupElement(element);\n            var popup = document.getElementById('dcm-svg-popup');\n            var iframe = document.getElementById('popup-iframe');\n            var svgRect = evt.target.getBoundingClientRect();\n            var svg = document.querySelector('svg');\n            var svgPoint = svg.createSVGPoint();\n            svgPoint.x = evt.clientX - svgRect.left;\n            svgPoint.y = evt.clientY - svgRect.top;\n\n            // Position the popup near the click event\n            popup.setAttribute('x', svgPoint.x);\n            popup.setAttribute('y', svgPoint.y);\n            // Set the iframe src and make the popup visible\n            iframe.setAttribute('src', url);\n            popup.setAttribute('visibility', 'visible');\n        }\n\n        function selectPopupElement(element) {\n            var popup = document.getElementById('dcm-svg-popup');\n\n            // Deselect the current element if there is one\n            if (popup.currentElement) {\n                popup.currentElement.classList.remove('selected');\n            }\n\n            // Select the new element\n            if (element) {\n                element.classList.add('selected');\n                popup.currentElement = element; // Update the reference to the currently selected element\n            } else {\n                popup.currentElement = null; // Clear the reference if no element is passed\n            }\n        }\n\n        function closePopup() {\n            var popup = document.getElementById('dcm-svg-popup');\n            popup.setAttribute('visibility', 'hidden');\n            // Deselect the element when the popup is closed\n            selectPopupElement(null);\n        }\n    &lt;/script&gt;\n    \"\"\"\n        return popup_script\n\n    def get_svg_markup(self, with_java_script: bool = False) -&gt; str:\n        \"\"\"\n        Generate the complete SVG markup.\n\n        Args:\n            with_java_script(bool): if True(default) the javascript code is included otherwise\n            it's available via the get_java_script function\n\n        Returns:\n            str: String containing the complete SVG markup.\n        \"\"\"\n        # Get current date and time\n        now = datetime.now()\n        formatted_now = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n        header = (\n            f\"&lt;!-- generated by dcm https://github.com/WolfgangFahl/dcm at {formatted_now} --&gt;\\n\"\n            f'&lt;svg xmlns=\"http://www.w3.org/2000/svg\" '\n            f'xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n            f'width=\"{self.width}\" height=\"{self.config.total_height}\"&gt;\\n'\n        )\n        popup = (\n            \"\"\"\n        &lt;!-- Add a foreignObject for the popup --&gt;\n&lt;foreignObject id=\"dcm-svg-popup\" class=\"popup\" width=\"500\" height=\"354\" x=\"150\" y=\"260\" visibility=\"hidden\"&gt;\n    &lt;body xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n        &lt;!-- Content of your popup goes here --&gt;\n        &lt;div class=\"popup\" style=\"background-color: white; border: 1px solid black; padding: 10px; box-sizing: border-box; width: 500px; height: 354px; position: relative;\"&gt;\n            &lt;span onclick=\"closePopup()\" class=\"close-btn\"&gt;\u24e7&lt;/span&gt;\n            &lt;iframe id=\"popup-iframe\" width=\"100%\" height=\"100%\" frameborder=\"0\"&gt;&lt;/iframe&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/foreignObject&gt;\n\"\"\"\n            if self.config.with_popup\n            else \"\"\n        )\n        styles = self.get_svg_style()\n        body = \"\".join(self.elements)\n        footer = \"&lt;/svg&gt;\"\n        java_script = self.get_java_script() if with_java_script else \"\"\n        svg_markup = f\"{header}{java_script}{styles}{body}{popup}{footer}\"\n        return svg_markup\n\n    def save(self, filename: str):\n        \"\"\"\n        Save the SVG markup to a file.\n\n        Args:\n            filename (str): Filename to save the SVG markup.\n        \"\"\"\n        with open(filename, \"w\") as file:\n            file.write(self.get_svg_markup())\n</code></pre>"},{"location":"#dcm.svg.SVG.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize SVG object with given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SVGConfig</code> <p>Configuration for SVG generation.</p> <code>None</code> Source code in <code>dcm/svg.py</code> <pre><code>def __init__(self, config: SVGConfig = None):\n    \"\"\"\n    Initialize SVG object with given configuration.\n\n    Args:\n        config (SVGConfig): Configuration for SVG generation.\n    \"\"\"\n    self.config = config if config else SVGConfig()\n    self.width = self.config.width\n    self.height = self.config.height\n    self.elements = []\n    self.indent = self.config.indent\n</code></pre>"},{"location":"#dcm.svg.SVG.add_circle","title":"<code>add_circle(config)</code>","text":"<p>Add a circle element to the SVG, optionally making it clickable and with a hover effect.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SVGNodeConfig</code> <p>Configuration for the circle element.</p> required Source code in <code>dcm/svg.py</code> <pre><code>    def add_circle(self, config: SVGNodeConfig):\n        \"\"\"\n        Add a circle element to the SVG, optionally making it clickable and with a hover effect.\n\n        Args:\n            config (SVGNodeConfig): Configuration for the circle element.\n        \"\"\"\n        color = config.fill if config.fill else self.config.default_color\n        circle_element = f'&lt;circle cx=\"{config.x}\" cy=\"{config.y}\" r=\"{config.width}\" fill=\"{color}\" class=\"{config.element_class}\" /&gt;'\n\n        # If URL is provided, wrap the circle in an anchor tag to make it clickable\n        if config.url:\n            circle_indent = self.get_indent(config.indent_level + 1)\n            circle_element = f\"\"\"&lt;a xlink:href=\"{config.url}\" target=\"_blank\"&gt;\n{circle_indent}{circle_element}\n&lt;/a&gt;\"\"\"\n\n        # Use add_group to add the circle element with proper indentation\n        self.add_group(\n            circle_element,\n            group_id=config.id,\n            group_class=config.element_class,\n            indent_level=config.indent_level,\n            comment=config.comment,\n        )\n</code></pre>"},{"location":"#dcm.svg.SVG.add_donut_segment","title":"<code>add_donut_segment(config, segment)</code>","text":"<p>Add a donut segment to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SVGNodeConfig</code> <p>Configuration for the donut segment.</p> required Source code in <code>dcm/svg.py</code> <pre><code>def add_donut_segment(\n    self,\n    config: SVGNodeConfig,\n    segment: DonutSegment,\n) -&gt; None:\n    \"\"\"\n    Add a donut segment to the SVG.\n\n    Args:\n        config (SVGNodeConfig): Configuration for the donut segment.\n        segment(DonutSegment)\n    \"\"\"\n    color = config.fill if config.fill else self.config.default_color\n    stroke_color = config.color if config.color else \"black\"\n\n    path_str = self.get_donut_path(segment)\n\n    # Assemble the path and title elements\n    path_element = (\n        f'&lt;path d=\"{path_str}\" stroke=\"{stroke_color}\" fill=\"{color}\" /&gt;\\n'\n    )\n    if config.title:\n        escaped_title = html.escape(config.title)  # Escape special characters\n\n        title_element = f\"&lt;title&gt;{escaped_title}&lt;/title&gt;\"\n    else:\n        title_element = \"\"\n    # Combine path and title into one string without adding indentation here\n    group_content = f\"{path_element}{title_element}\"\n\n    # Check if the segment should be shown as a popup\n    if config.show_as_popup:\n        # Add JavaScript to handle popup logic\n        onclick_action = f\"onclick=\\\"showPopup('{config.url}', evt,this)\\\"\"\n        group_content = f\"&lt;g {onclick_action}&gt;{group_content}&lt;/g&gt;\"\n    elif config.url:\n        # Regular link behavior\n        group_content = (\n            f'&lt;a xlink:href=\"{config.url}\" target=\"_blank\"&gt;{group_content}&lt;/a&gt;'\n        )\n\n    # Use add_group to add the pie segment with proper indentation\n    self.add_group(\n        group_content,\n        group_id=config.id,\n        group_class=config.element_class,\n        indent_level=2,\n        comment=config.comment,\n    )\n</code></pre>"},{"location":"#dcm.svg.SVG.add_element","title":"<code>add_element(element, indent_level=1, comment=None)</code>","text":"<p>Add an SVG element to the elements list with proper indentation.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>SVG element to be added.</p> required <code>indent_level</code> <code>int</code> <p>Indentation level for the element.</p> <code>1</code> <code>comment(str)</code> <p>optional comment to add</p> required Source code in <code>dcm/svg.py</code> <pre><code>def add_element(self, element: str, indent_level: int = 1, comment: str = None):\n    \"\"\"\n    Add an SVG element to the elements list with proper indentation.\n\n    Args:\n        element (str): SVG element to be added.\n        indent_level (int): Indentation level for the element.\n        comment(str): optional comment to add\n    \"\"\"\n    base_indent = self.get_indent(indent_level)\n    if comment:\n        indented_comment = f\"{base_indent}&lt;!-- {comment} --&gt;\\n\"\n        self.elements.append(indented_comment)\n    indented_element = f\"{base_indent}{element}\\n\"\n    self.elements.append(indented_element)\n</code></pre>"},{"location":"#dcm.svg.SVG.add_group","title":"<code>add_group(content, group_id=None, group_class=None, indent_level=1, comment=None)</code>","text":"<p>Add a group of elements to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>SVG content to be grouped.</p> required <code>group_id</code> <code>str</code> <p>ID for the group.</p> <code>None</code> <code>group_class</code> <code>str</code> <p>Class for the group.</p> <code>None</code> <code>indent_level</code> <code>int</code> <p>Indentation level for the group.</p> <code>1</code> Source code in <code>dcm/svg.py</code> <pre><code>    def add_group(\n        self,\n        content: str,\n        group_id: str = None,\n        group_class: str = None,\n        indent_level: int = 1,\n        comment: str = None,\n    ):\n        \"\"\"\n        Add a group of elements to the SVG.\n\n        Args:\n            content (str): SVG content to be grouped.\n            group_id (str, optional): ID for the group.\n            group_class (str, optional): Class for the group.\n            indent_level (int): Indentation level for the group.\n        \"\"\"\n        group_attrs = []\n        if group_id:\n            group_attrs.append(f'id=\"{group_id}\"')\n        if group_class:\n            group_attrs.append(f'class=\"{group_class}\"')\n        attrs_str = \" \".join(group_attrs)\n        indented_content = \"\\n\".join(\n            f\"{self.get_indent(indent_level + 1)}{line}\"\n            for line in content.strip().split(\"\\n\")\n        )\n        group_str = f\"\"\"{self.get_indent(indent_level)}&lt;g {attrs_str}&gt;\n{indented_content}\n{self.get_indent(indent_level)}&lt;/g&gt;\n\"\"\"\n        self.add_element(group_str, indent_level=indent_level, comment=comment)\n</code></pre>"},{"location":"#dcm.svg.SVG.add_legend_column","title":"<code>add_legend_column(items, title, x, y, width, height)</code>","text":"<p>Add a legend column to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[Tuple[str, str]]</code> <p>List of tuples with color code and label.</p> required <code>title</code> <code>str</code> <p>Title of the legend.</p> required <code>x</code> <code>int</code> <p>X position of the legend.</p> required <code>y</code> <code>int</code> <p>Y position of the legend.</p> required <code>width</code> <code>int</code> <p>Width of the color box in the legend.</p> required <code>height</code> <code>int</code> <p>Height of each legend item.</p> required Source code in <code>dcm/svg.py</code> <pre><code>def add_legend_column(\n    self,\n    items: List[Tuple[str, str]],\n    title: str,\n    x: int,\n    y: int,\n    width: int,\n    height: int,\n) -&gt; None:\n    \"\"\"\n    Add a legend column to the SVG.\n\n    Args:\n        items (List[Tuple[str, str]]): List of tuples with color code and label.\n        title (str): Title of the legend.\n        x (int): X position of the legend.\n        y (int): Y position of the legend.\n        width (int): Width of the color box in the legend.\n        height (int): Height of each legend item.\n    \"\"\"\n    self.add_text(x, y - height, title, font_weight=\"bold\")\n    for index, (color, label) in enumerate(items):\n        self.add_rectangle(x, y + index * (height + 5), width, height, color)\n        self.add_text(\n            x + width + 10,\n            y + index * (height + 5) + height / 2,\n            label,\n            center_v=True,\n        )\n</code></pre>"},{"location":"#dcm.svg.SVG.add_polygon","title":"<code>add_polygon(polygon, indent_level=1)</code>","text":"<p>Add a polygon to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>Polygon</code> <p>The polygon to add to the SVG.</p> required <code>indent_level</code> <code>int</code> <p>Indentation level for the element.</p> <code>1</code> Source code in <code>dcm/svg.py</code> <pre><code>def add_polygon(self, polygon: Polygon, indent_level: int = 1):\n    \"\"\"\n    Add a polygon to the SVG.\n\n    Args:\n        polygon (Polygon): The polygon to add to the SVG.\n        indent_level (int): Indentation level for the element.\n    \"\"\"\n    points_str = \" \".join(f\"{x},{y}\" for x, y in polygon.points)\n    fill_color = polygon.fill if polygon.fill else self.config.default_color\n    opacity = polygon.opacity\n    stroke_color = polygon.color if polygon.color else \"black\"\n    stroke_width = polygon.stroke_width\n\n    polygon_element = (\n        f'&lt;polygon points=\"{points_str}\" '\n        f'stroke=\"{stroke_color}\" stroke-width=\"{stroke_width}\" '\n        f'fill=\"{fill_color}\" fill-opacity=\"{opacity}\" /&gt;\\n'\n    )\n\n    # If a title (tooltip) is provided, create a title element\n    title_element = (\n        f\"&lt;title&gt;{html.escape(polygon.title)}&lt;/title&gt;\\n\" if polygon.title else \"\"\n    )\n\n    # Combine polygon and title into one string without adding indentation here\n    group_content = f\"{polygon_element}{title_element}\"\n\n    # Use add_group to add the polygon with proper indentation and optional comment\n    self.add_group(\n        group_content,\n        group_id=polygon.id,\n        group_class=\"hoverable\",  # You might want to adjust this or make it configurable\n        indent_level=indent_level,\n        comment=polygon.comment,\n    )\n</code></pre>"},{"location":"#dcm.svg.SVG.add_rectangle","title":"<code>add_rectangle(x, y, width, height, fill=None, indent_level=1)</code>","text":"<p>Add a rectangle element to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X-coordinate of the rectangle's top-left corner.</p> required <code>y</code> <code>int</code> <p>Y-coordinate of the rectangle's top-left corner.</p> required <code>width</code> <code>int</code> <p>Width of the rectangle.</p> required <code>height</code> <code>int</code> <p>Height of the rectangle.</p> required <code>fill</code> <code>str</code> <p>Fill color of the rectangle. Defaults to the default color.</p> <code>None</code> <code>indent_level</code> <code>int</code> <p>Indentation level for the rectangle.</p> <code>1</code> Source code in <code>dcm/svg.py</code> <pre><code>def add_rectangle(\n    self,\n    x: int,\n    y: int,\n    width: int,\n    height: int,\n    fill: str = None,\n    indent_level: int = 1,\n):\n    \"\"\"\n    Add a rectangle element to the SVG.\n\n    Args:\n        x (int): X-coordinate of the rectangle's top-left corner.\n        y (int): Y-coordinate of the rectangle's top-left corner.\n        width (int): Width of the rectangle.\n        height (int): Height of the rectangle.\n        fill (str, optional): Fill color of the rectangle. Defaults to the default color.\n        indent_level (int): Indentation level for the rectangle.\n    \"\"\"\n    color = fill if fill else self.config.default_color\n    rect = f'&lt;rect x=\"{x}\" y=\"{y}\" width=\"{width}\" height=\"{height}\" fill=\"{color}\" /&gt;\\n'\n    self.add_element(rect, indent_level=indent_level)\n</code></pre>"},{"location":"#dcm.svg.SVG.add_text","title":"<code>add_text(x, y, text, fill='black', font_weight='normal', text_anchor='start', transform='', center_v=False, text_class='noclick', indent_level=1)</code>","text":"<p>Add text to the SVG.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X position of the text.</p> required <code>y</code> <code>int</code> <p>Y position of the text.</p> required <code>text(str)</code> <p>Text content.</p> required <code>fill</code> <code>str</code> <p>Fill color of the text. Defaults to \"black\".</p> <code>'black'</code> <code>font_weight</code> <code>str</code> <p>Font weight (normal, bold, etc.). Defaults to \"normal\".</p> <code>'normal'</code> <code>text_anchor</code> <code>str</code> <p>Text alignment (start, middle, end). Defaults to \"start\".</p> <code>'start'</code> <code>indent_level(int)</code> <p>the indentation level to apply</p> required <code>center_v</code> <code>bool</code> <p>If True, y as the vertical center of the text. Default is False.</p> <code>False</code> <code>text_class(str)</code> <p>\"noclick\" by default so that elements below are clickable</p> required <code>transform</code> <code>str</code> <p>Transformation for the text (e.g., rotation). Defaults to an empty string.</p> <code>''</code> Source code in <code>dcm/svg.py</code> <pre><code>def add_text(\n    self,\n    x: int,\n    y: int,\n    text: str,\n    fill: str = \"black\",\n    font_weight: str = \"normal\",\n    text_anchor: str = \"start\",\n    transform: str = \"\",\n    center_v: bool = False,\n    text_class: str = \"noclick\",\n    indent_level: int = 1,\n) -&gt; None:\n    \"\"\"\n    Add text to the SVG.\n\n    Args:\n        x (int): X position of the text.\n        y (int): Y position of the text.\n        text(str): Text content.\n        fill (str, optional): Fill color of the text. Defaults to \"black\".\n        font_weight (str, optional): Font weight (normal, bold, etc.). Defaults to \"normal\".\n        text_anchor (str, optional): Text alignment (start, middle, end). Defaults to \"start\".\n        indent_level(int): the indentation level to apply\n        center_v (bool): If True, y as the vertical center of the text. Default is False.\n        text_class(str): \"noclick\" by default so that elements below are clickable\n        transform (str, optional): Transformation for the text (e.g., rotation). Defaults to an empty string.\n    \"\"\"\n    text_obj = Text(text, self.config)\n    if center_v:\n        # y-offset adjustment to center the text vertically\n        y -= text_obj.total_text_height / 2\n        # adjust for the ascender / descender vertical font weighting\n        y -= self.config.font_size * 0.5\n    # Create a text element to hold the tspan elements\n    # Only include the transform attribute if it is provided\n    transform_attr = f'transform=\"{transform}\" ' if transform else \"\"\n\n    text_element = (\n        f'\\n{self.get_indent(indent_level)}&lt;text class=\"{text_class}\" x=\"{x}\" y=\"{y}\" fill=\"{fill}\" '\n        f'font-family=\"{self.config.font}\" '\n        f'font-size=\"{self.config.font_size}\" '\n        f'font-weight=\"{font_weight}\" '\n        f'text-anchor=\"{text_anchor}\" '\n        f'dominant-baseline=\"middle\" '\n        f\"{transform_attr}&gt;\"\n    )\n    # Add tspan elements for each line\n    for line in text_obj.lines:\n        escaped_line = html.escape(line)\n        text_element += f'\\n{self.get_indent(indent_level+1)}&lt;tspan x=\"{x}\" dy=\"{self.config.line_height}\"&gt;{escaped_line}&lt;/tspan&gt;'\n\n    text_element += f\"\\n{self.get_indent(indent_level)}&lt;/text&gt;\\n\"\n    self.add_element(text_element)\n</code></pre>"},{"location":"#dcm.svg.SVG.add_text_to_donut_segment","title":"<code>add_text_to_donut_segment(segment, text, direction='horizontal', color='white', text_class='noclick', indent_level=1)</code>","text":"<p>Add text to a donut segment with various direction options.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>DonutSegment</code> <p>The donut segment to which text will be added.</p> required <code>text</code> <code>str</code> <p>The text content to be added.</p> required <code>direction</code> <code>str</code> <p>The direction in which the text should be drawn.              Options are \"horizontal\", \"angled\", or \"curved\".</p> <code>'horizontal'</code> <code>color</code> <code>str</code> <p>The color of the text. Default is \"white\".</p> <code>'white'</code> Source code in <code>dcm/svg.py</code> <pre><code>def add_text_to_donut_segment(\n    self,\n    segment: DonutSegment,\n    text: str,\n    direction: str = \"horizontal\",\n    color: str = \"white\",\n    text_class: str = \"noclick\",\n    indent_level: int = 1,\n) -&gt; None:\n    \"\"\"\n    Add text to a donut segment with various direction options.\n\n    Args:\n        segment (DonutSegment): The donut segment to which text will be added.\n        text (str): The text content to be added.\n        direction (str): The direction in which the text should be drawn.\n                         Options are \"horizontal\", \"angled\", or \"curved\".\n        color (str): The color of the text. Default is \"white\".\n    \"\"\"\n    if direction in [\"horizontal\", \"angled\"]:\n        # Calculate position for horizontal or angled text\n        # Use the get_arc method to find the position for horizontal or angled text\n        mid_arc = segment.get_arc(radial_offset=0.5)  # Get the mid-arc\n        text_x, text_y = mid_arc.middle_x, mid_arc.middle_y\n\n        # Adjust text anchor and rotation for better readability\n        transform = \"\"\n        if direction == \"angled\":\n            mid_angle = segment.relative_angle(0.5)\n            rotation_angle = self.get_text_rotation(mid_angle)\n            transform = f\"rotate({rotation_angle}, {text_x}, {text_y})\"\n\n        # Add text using the add_text method\n        self.add_text(\n            x=text_x,\n            y=text_y,\n            text=text,\n            fill=color,\n            font_weight=\"normal\",\n            indent_level=indent_level,\n            transform=transform,\n            text_anchor=\"middle\",\n            center_v=True,\n        )\n\n    elif direction == \"curved\":\n        text_obj = Text(text, self.config)\n\n        for i, line in enumerate(text_obj.lines):\n            radial_offset = 1 - ((i + 1) / (text_obj.line_count + 1))\n            # Create a path for the text to follow\n            path_id = f\"path{segment.start_angle}-{segment.end_angle}-{i}\"\n            path_d = self.get_donut_path(\n                segment, middle_arc=True, radial_offset=radial_offset\n            )\n            self.add_element(\n                f'&lt;path id=\"{path_id}\" d=\"{path_d}\" fill=\"none\" stroke=\"none\" /&gt;'\n            )\n\n            text_tag = f\"\"\"&lt;text class=\"{text_class}\" fill=\"{color}\" font-family=\"{self.config.font}\" font-size=\"{self.config.font_size}\"&gt;\"\"\"\n            self.add_element(text_tag, indent_level=indent_level)\n            text_path = f\"\"\"&lt;textPath  xlink:href=\"#{path_id}\" startOffset=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\"&gt;{html.escape(line)}&lt;/textPath&gt;\"\"\"\n            self.add_element(text_path, indent_level=indent_level + 1)\n            self.add_element(\"&lt;/text&gt;\", indent_level=indent_level)\n    else:\n        raise ValueError(f\"invalid direction {direction}\")\n</code></pre>"},{"location":"#dcm.svg.SVG.get_donut_path","title":"<code>get_donut_path(segment, radial_offset=0.5, middle_arc=False)</code>","text":"<p>Create an SVG path definition for an arc using the properties of a DonutSegment.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>DonutSegment</code> <p>The segment for which to create the path.</p> required <code>radial_offset(float)</code> <p>0 to 1 - useable in middle_arc mode</p> required <code>middle_arc(bool)</code> <p>if True get the middle arc</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>SVG path definition string for the full donut segment or the middle_arc if middle_arc is set to true.</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_donut_path(\n    self,\n    segment: DonutSegment,\n    radial_offset: float = 0.5,\n    middle_arc: bool = False,\n) -&gt; str:\n    \"\"\"\n    Create an SVG path definition for an arc using the properties of a DonutSegment.\n\n    Args:\n        segment (DonutSegment): The segment for which to create the path.\n        radial_offset(float): 0 to 1 - useable in middle_arc mode\n        middle_arc(bool): if True get the middle arc\n\n    Returns:\n        str: SVG path definition string for the full donut segment or the middle_arc if middle_arc is set to true.\n    \"\"\"\n    if middle_arc:\n        arc = segment.get_arc(radial_offset=radial_offset)\n\n        # Create the path for the middle arc\n        path_str = (\n            f\"M {arc.start_x} {arc.start_y} \"  # Move to start of middle arc\n            f\"A {arc.radius} {arc.radius} 0 {segment.large_arc_flag} 1 {arc.end_x} {arc.end_y}\"\n        )\n    else:\n        outer_arc = segment.get_arc(radial_offset=1)\n        inner_arc = segment.get_arc(radial_offset=0)\n        path_str = (\n            f\"M {inner_arc.start_x} {inner_arc.start_y} \"  # Move to start of inner arc\n            f\"L {outer_arc.start_x} {outer_arc.start_y} \"  # Line to start of outer arc\n            f\"A {segment.outer_radius} {segment.outer_radius} 0 {segment.large_arc_flag} 1 {outer_arc.end_x} {outer_arc.end_y} \"  # Outer arc\n            f\"L {inner_arc.end_x} {inner_arc.end_y} \"  # Line to end of inner arc\n            f\"A {segment.inner_radius} {segment.inner_radius} 0 {segment.large_arc_flag} 0 {inner_arc.start_x} {inner_arc.start_y} \"  # Inner arc (reverse)\n            \"Z\"\n        )\n\n    return path_str\n</code></pre>"},{"location":"#dcm.svg.SVG.get_indent","title":"<code>get_indent(level)</code>","text":"<p>get the indentation for the given level</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_indent(self, level) -&gt; str:\n    \"\"\"\n    get the indentation for the given level\n    \"\"\"\n    indentation = f\"{self.indent * level}\"\n    return indentation\n</code></pre>"},{"location":"#dcm.svg.SVG.get_java_script","title":"<code>get_java_script()</code>","text":"<p>get the java script code for interactive behavior</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_java_script(self) -&gt; str:\n    \"\"\"\n    get the java script code for interactive behavior\n    \"\"\"\n    popup_script = \"\"\"\n&lt;script&gt;\n     function showPopup(url, evt,element) {\n        // show a Popup fetching html content from the given url\n        // for the given element\n        // Handle the selection of the popup element\n        selectPopupElement(element);\n        var popup = document.getElementById('dcm-svg-popup');\n        var iframe = document.getElementById('popup-iframe');\n        var svgRect = evt.target.getBoundingClientRect();\n        var svg = document.querySelector('svg');\n        var svgPoint = svg.createSVGPoint();\n        svgPoint.x = evt.clientX - svgRect.left;\n        svgPoint.y = evt.clientY - svgRect.top;\n\n        // Position the popup near the click event\n        popup.setAttribute('x', svgPoint.x);\n        popup.setAttribute('y', svgPoint.y);\n        // Set the iframe src and make the popup visible\n        iframe.setAttribute('src', url);\n        popup.setAttribute('visibility', 'visible');\n    }\n\n    function selectPopupElement(element) {\n        var popup = document.getElementById('dcm-svg-popup');\n\n        // Deselect the current element if there is one\n        if (popup.currentElement) {\n            popup.currentElement.classList.remove('selected');\n        }\n\n        // Select the new element\n        if (element) {\n            element.classList.add('selected');\n            popup.currentElement = element; // Update the reference to the currently selected element\n        } else {\n            popup.currentElement = null; // Clear the reference if no element is passed\n        }\n    }\n\n    function closePopup() {\n        var popup = document.getElementById('dcm-svg-popup');\n        popup.setAttribute('visibility', 'hidden');\n        // Deselect the element when the popup is closed\n        selectPopupElement(null);\n    }\n&lt;/script&gt;\n\"\"\"\n    return popup_script\n</code></pre>"},{"location":"#dcm.svg.SVG.get_svg_markup","title":"<code>get_svg_markup(with_java_script=False)</code>","text":"<p>Generate the complete SVG markup.</p> <p>Parameters:</p> Name Type Description Default <code>with_java_script(bool)</code> <p>if True(default) the javascript code is included otherwise</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String containing the complete SVG markup.</p> Source code in <code>dcm/svg.py</code> <pre><code>    def get_svg_markup(self, with_java_script: bool = False) -&gt; str:\n        \"\"\"\n        Generate the complete SVG markup.\n\n        Args:\n            with_java_script(bool): if True(default) the javascript code is included otherwise\n            it's available via the get_java_script function\n\n        Returns:\n            str: String containing the complete SVG markup.\n        \"\"\"\n        # Get current date and time\n        now = datetime.now()\n        formatted_now = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n        header = (\n            f\"&lt;!-- generated by dcm https://github.com/WolfgangFahl/dcm at {formatted_now} --&gt;\\n\"\n            f'&lt;svg xmlns=\"http://www.w3.org/2000/svg\" '\n            f'xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n            f'width=\"{self.width}\" height=\"{self.config.total_height}\"&gt;\\n'\n        )\n        popup = (\n            \"\"\"\n        &lt;!-- Add a foreignObject for the popup --&gt;\n&lt;foreignObject id=\"dcm-svg-popup\" class=\"popup\" width=\"500\" height=\"354\" x=\"150\" y=\"260\" visibility=\"hidden\"&gt;\n    &lt;body xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n        &lt;!-- Content of your popup goes here --&gt;\n        &lt;div class=\"popup\" style=\"background-color: white; border: 1px solid black; padding: 10px; box-sizing: border-box; width: 500px; height: 354px; position: relative;\"&gt;\n            &lt;span onclick=\"closePopup()\" class=\"close-btn\"&gt;\u24e7&lt;/span&gt;\n            &lt;iframe id=\"popup-iframe\" width=\"100%\" height=\"100%\" frameborder=\"0\"&gt;&lt;/iframe&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/foreignObject&gt;\n\"\"\"\n            if self.config.with_popup\n            else \"\"\n        )\n        styles = self.get_svg_style()\n        body = \"\".join(self.elements)\n        footer = \"&lt;/svg&gt;\"\n        java_script = self.get_java_script() if with_java_script else \"\"\n        svg_markup = f\"{header}{java_script}{styles}{body}{popup}{footer}\"\n        return svg_markup\n</code></pre>"},{"location":"#dcm.svg.SVG.get_svg_style","title":"<code>get_svg_style()</code>","text":"<p>Define styles for SVG elements.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String containing style definitions for SVG.</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_svg_style(self) -&gt; str:\n    \"\"\"\n    Define styles for SVG elements.\n\n    Returns:\n        str: String containing style definitions for SVG.\n    \"\"\"\n    style = (\n        f\"{self.indent}&lt;style&gt;\\n\"\n        f\"{self.indent * 2}.hoverable {{ cursor: pointer; fill-opacity: 1; stroke: black; stroke-width: 0.5; }}\\n\"\n        f\"{self.indent * 2}.hoverable:hover {{ fill-opacity: 0.7; }}\\n\"\n        f\"{self.indent * 2}.selected {{ fill-opacity: 0.5; stroke: blue !important; stroke-width: 1.5;}}\\n\"\n        f\"{self.indent * 2}.noclick {{ pointer-events: none; }}\\n\"  # style for non-clickable text\n    )\n\n    if self.config.with_popup:\n        style += (\n            f\"{self.indent * 2}.popup {{\\n\"\n            f\"{self.indent * 3}border: 2px solid black;\\n\"\n            f\"{self.indent * 3}border-radius: 15px;\\n\"\n            f\"{self.indent * 3}overflow: auto;\\n\"  # changed to 'auto' to allow scrolling only if needed\n            f\"{self.indent * 3}background: white;\\n\"\n            f\"{self.indent * 3}box-sizing: border-box;\\n\"  # ensures padding and border are included\n            f\"{self.indent * 3}padding: 10px;\\n\"  # optional padding inside the popup\n            f\"{self.indent * 3}height: 100%;\\n\"  # adjusts height relative to foreignObject\n            f\"{self.indent * 3}width: 100%;\\n\"  # adjusts width relative to foreignObject\n            f\"{self.indent * 2}}}\\n\"\n            f\"{self.indent * 2}.close-btn {{\\n\"  # style for the close button\n            f\"{self.indent * 3}cursor: pointer;\\n\"\n            f\"{self.indent * 3}position: absolute;\\n\"\n            f\"{self.indent * 3}top: 0;\\n\"\n            f\"{self.indent * 3}right: 0;\\n\"\n            f\"{self.indent * 3}padding: 5px;\\n\"\n            f\"{self.indent * 3}font-size: 20px;\\n\"\n            f\"{self.indent * 3}user-select: none;\\n\"  # prevents text selection on click\n            f\"{self.indent * 2}}}\\n\"\n        )\n\n    style += f\"{self.indent}&lt;/style&gt;\\n\"\n    return style\n</code></pre>"},{"location":"#dcm.svg.SVG.get_text_rotation","title":"<code>get_text_rotation(rotation_angle)</code>","text":"<p>Adjusts the rotation angle for SVG text elements to ensure that the text is upright and readable in a circular chart. The text will be rotated by 180 degrees if it is in the lower half of the chart (between 90 and 270 degrees).</p> <p>Parameters:</p> Name Type Description Default <code>rotation_angle</code> <code>float</code> <p>The initial rotation angle of the text element.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The adjusted rotation angle for the text element.</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_text_rotation(self, rotation_angle: float) -&gt; float:\n    \"\"\"\n    Adjusts the rotation angle for SVG text elements to ensure that the text\n    is upright and readable in a circular chart. The text will be rotated\n    by 180 degrees if it is in the lower half of the chart (between 90 and 270 degrees).\n\n    Args:\n        rotation_angle (float): The initial rotation angle of the text element.\n\n    Returns:\n        float: The adjusted rotation angle for the text element.\n    \"\"\"\n    # In the bottom half of the chart (90 to 270 degrees), the text\n    # would appear upside down, so we rotate it by 180 degrees.\n    if 90 &lt;= rotation_angle &lt; 270:\n        rotation_angle -= 180\n\n    # Return the adjusted angle. No adjustment is needed for the\n    # top half of the chart as the text is already upright.\n    return rotation_angle\n</code></pre>"},{"location":"#dcm.svg.SVG.get_text_width","title":"<code>get_text_width(text)</code>","text":"<p>Estimate the width of a text string in the SVG based on the font size and font name.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text content.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The estimated width of the text in pixels.</p> Source code in <code>dcm/svg.py</code> <pre><code>def get_text_width(self, text: str) -&gt; int:\n    \"\"\"\n    Estimate the width of a text string in the SVG based on the font size and font name.\n\n    Args:\n        text (str): The text content.\n\n    Returns:\n        int: The estimated width of the text in pixels.\n    \"\"\"\n    average_char_width_factor = 0.6\n    average_char_width = average_char_width_factor * self.config.font_size\n    return int(average_char_width * len(text))\n</code></pre>"},{"location":"#dcm.svg.SVG.save","title":"<code>save(filename)</code>","text":"<p>Save the SVG markup to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename to save the SVG markup.</p> required Source code in <code>dcm/svg.py</code> <pre><code>def save(self, filename: str):\n    \"\"\"\n    Save the SVG markup to a file.\n\n    Args:\n        filename (str): Filename to save the SVG markup.\n    \"\"\"\n    with open(filename, \"w\") as file:\n        file.write(self.get_svg_markup())\n</code></pre>"},{"location":"#dcm.svg.SVGConfig","title":"<code>SVGConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for SVG generation.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>int</code> <p>Width of the SVG canvas in pixels.</p> <code>height</code> <code>int</code> <p>Height of the SVG canvas in pixels.</p> <code>legend_height</code> <code>int</code> <p>Height reserved for the legend in pixels.</p> <code>font</code> <code>str</code> <p>Font family for text elements.</p> <code>font_size</code> <code>int</code> <p>Font size in points for text elements.</p> <code>indent</code> <code>str</code> <p>Indentation string, default is two spaces.</p> <code>default_color</code> <code>str</code> <p>Default color code for SVG elements.</p> <code>with_pop(bool)</code> <code>str</code> <p>if True support popup javascript functionality</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass SVGConfig:\n    \"\"\"\n    Configuration class for SVG generation.\n\n    Attributes:\n        width (int): Width of the SVG canvas in pixels.\n        height (int): Height of the SVG canvas in pixels.\n        legend_height (int): Height reserved for the legend in pixels.\n        font (str): Font family for text elements.\n        font_size (int): Font size in points for text elements.\n        indent (str): Indentation string, default is two spaces.\n        default_color (str): Default color code for SVG elements.\n        with_pop(bool): if True support popup javascript functionality\n    \"\"\"\n\n    width: int = 600\n    height: int = 600\n    legend_height: int = 150\n    font: str = \"Arial\"\n    font_size: int = 12\n    indent: str = \"  \"\n    default_color: str = \"#C0C0C0\"\n    with_popup: bool = False\n\n    @property\n    def total_height(self) -&gt; int:\n        \"\"\"\n        Calculate total height of the SVG canvas including the legend.\n\n        Returns:\n            int: Total height of the SVG canvas.\n        \"\"\"\n        return self.height + self.legend_height\n\n    @property\n    def line_height(self) -&gt; float:\n        # Calculate line height based on font size\n        # You can adjust this multiplier as needed\n        line_height = self.font_size * 1.2\n        return line_height\n</code></pre>"},{"location":"#dcm.svg.SVGConfig.total_height","title":"<code>total_height: int</code>  <code>property</code>","text":"<p>Calculate total height of the SVG canvas including the legend.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total height of the SVG canvas.</p>"},{"location":"#dcm.svg.SVGNode","title":"<code>SVGNode</code>  <code>dataclass</code>","text":"<p>a generic SVG Node</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass SVGNode:\n    \"\"\"\n    a generic SVG Node\n    \"\"\"\n\n    indent_level: int = 1\n    id: Optional[str] = None\n    color: Optional[str] = (\n        None  # Color of font or stroke use default color of config if None\n    )\n    stroke_width: float = 1.0  # Stroke width of the polygon lines\n    opacity: float = 0.5  # Opacity of fill e.g. for polygons\n    fill: Optional[str] = \"black\"  # Fill color for the segment\n    title: Optional[str] = None  # Tooltip\n    comment: Optional[str] = None\n</code></pre>"},{"location":"#dcm.svg.SVGNodeConfig","title":"<code>SVGNodeConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SVGNode</code></p> <p>a single SVG Node configuration to display any element</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass SVGNodeConfig(SVGNode):\n    \"\"\"\n    a single SVG Node configuration\n    to display any element\n    \"\"\"\n\n    x: float = 0.0\n    y: float = 0.0\n    width: Optional[float] = None\n    height: Optional[float] = None\n    element_type: Optional[str] = None\n    url: Optional[str] = None\n    show_as_popup: bool = False  # Flag to indicate if the link should opened as a popup\n    element_class: Optional[str] = \"hoverable\"\n</code></pre>"},{"location":"#dcm.svg.Text","title":"<code>Text</code>  <code>dataclass</code>","text":"<p>Class to handle text-related operations in SVG.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The text content.</p> <code>config</code> <code>SVGConfig</code> <p>Configuration for SVG generation.</p> Source code in <code>dcm/svg.py</code> <pre><code>@dataclass\nclass Text:\n    \"\"\"\n    Class to handle text-related operations in SVG.\n\n    Attributes:\n        text (str): The text content.\n        config (SVGConfig): Configuration for SVG generation.\n    \"\"\"\n\n    text: str\n    config: SVGConfig\n    lines: List[str] = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization processing to split the text into lines.\n        \"\"\"\n        self.lines = self.text.strip().split(\"\\n\")\n\n    @property\n    def line_count(self) -&gt; int:\n        return len(self.lines)\n\n    @property\n    def total_text_height(self) -&gt; float:\n        \"\"\"\n        Calculate the total height of the text based on the number of lines and the line height.\n\n        Returns:\n            float: The total height of the text in pixels.\n        \"\"\"\n        height = self.config.line_height * len(self.lines)\n        return height\n</code></pre>"},{"location":"#dcm.svg.Text.total_text_height","title":"<code>total_text_height: float</code>  <code>property</code>","text":"<p>Calculate the total height of the text based on the number of lines and the line height.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total height of the text in pixels.</p>"},{"location":"#dcm.svg.Text.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing to split the text into lines.</p> Source code in <code>dcm/svg.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization processing to split the text into lines.\n    \"\"\"\n    self.lines = self.text.strip().split(\"\\n\")\n</code></pre>"},{"location":"#dcm.version","title":"<code>version</code>","text":"<p>Created on 2023-11-06</p> <p>@author: wf</p>"},{"location":"#dcm.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for nicepdf</p> Source code in <code>dcm/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for nicepdf\n    \"\"\"\n\n    name = \"dcm\"\n    version = dcm.__version__\n    date = \"2023-11-06\"\n    updated = \"2024-02-27\"\n    description = \"python based visualization of dynamic competence maps\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/dcm\"\n    chat_url = \"https://github.com/WolfgangFahl/dcm/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/dcm\"\n\n    license = f\"\"\"Copyright 2023 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#dcm.xapi","title":"<code>xapi</code>","text":"<p>Created on 2024-01-24</p> <p>Experience API xAPI support module @author: wf</p>"},{"location":"#dcm.xapi.XAPI","title":"<code>XAPI</code>","text":"<p>Experience API xAPI support class</p> Source code in <code>dcm/xapi.py</code> <pre><code>class XAPI:\n    \"\"\"\n    Experience API xAPI support class\n    \"\"\"\n\n    def __init__(self):\n        self.xapi_dict = {}\n\n    def warn(self, msg):\n        print(msg, file=sys.stderr)\n        pass\n\n    def to_learner(self, competence_tree: CompetenceTree) -&gt; Learner:\n        \"\"\"\n        Convert xapi_dict to a Learner with Achievements.\n        Args:\n            competence_tree (CompetenceTree): The competence tree to align the achievements with.\n        Returns:\n            Learner: A learner object with achievements mapped from xapi_dict.\n        \"\"\"\n        # Assuming each entry in xapi_dict is an xAPI statement relevant to a learning activity\n        achievements = []\n        actor_id = None\n        learner = None\n        for entry in self.xapi_dict:\n            stmt = entry.get(\"statement\")\n            if stmt:\n                actor = stmt.get(\"actor\")\n                if actor:\n                    # Extract necessary information from the xAPI statement\n                    new_actor_id = actor[\"account\"][\"name\"]\n                    if actor_id is None:\n                        actor_id = new_actor_id\n                    else:\n                        if new_actor_id != actor_id:\n                            self.warn(f\"invalid actor_id {new_actor_id} != {actor_id}\")\n                competence_path = stmt[\"context\"][\"extensions\"][\n                    \"learningObjectMetadata\"\n                ][\"competencePath\"]\n                score_scaled = stmt[\"result\"][\"score\"][\"scaled\"]\n                timestamp = stmt[\"timestamp\"]\n\n                # Create an Achievement instance\n                achievement = Achievement(\n                    path=competence_path,\n                    level=int(\n                        score_scaled * competence_tree.total_valid_levels\n                    ),  # Convert scaled score to level\n                    score=stmt[\"result\"][\"score\"][\"raw\"],\n                    date_assessed_iso=timestamp,\n                )\n                achievements.append(achievement)\n\n        if actor_id:\n            # Create a Learner instance with these achievements\n            learner = Learner(learner_id=actor_id, achievements=achievements)\n        else:\n            self.warn(\"no learner / actor defined\")\n        return learner\n\n    @classmethod\n    def from_json(cls, json_file_path: str):\n        xapi = cls()\n        # Open and read the JSON file\n        with open(json_file_path, \"r\") as json_file:\n            xapi.xapi_dict = json.load(json_file)\n        return xapi\n</code></pre>"},{"location":"#dcm.xapi.XAPI.to_learner","title":"<code>to_learner(competence_tree)</code>","text":"<p>Convert xapi_dict to a Learner with Achievements. Args:     competence_tree (CompetenceTree): The competence tree to align the achievements with. Returns:     Learner: A learner object with achievements mapped from xapi_dict.</p> Source code in <code>dcm/xapi.py</code> <pre><code>def to_learner(self, competence_tree: CompetenceTree) -&gt; Learner:\n    \"\"\"\n    Convert xapi_dict to a Learner with Achievements.\n    Args:\n        competence_tree (CompetenceTree): The competence tree to align the achievements with.\n    Returns:\n        Learner: A learner object with achievements mapped from xapi_dict.\n    \"\"\"\n    # Assuming each entry in xapi_dict is an xAPI statement relevant to a learning activity\n    achievements = []\n    actor_id = None\n    learner = None\n    for entry in self.xapi_dict:\n        stmt = entry.get(\"statement\")\n        if stmt:\n            actor = stmt.get(\"actor\")\n            if actor:\n                # Extract necessary information from the xAPI statement\n                new_actor_id = actor[\"account\"][\"name\"]\n                if actor_id is None:\n                    actor_id = new_actor_id\n                else:\n                    if new_actor_id != actor_id:\n                        self.warn(f\"invalid actor_id {new_actor_id} != {actor_id}\")\n            competence_path = stmt[\"context\"][\"extensions\"][\n                \"learningObjectMetadata\"\n            ][\"competencePath\"]\n            score_scaled = stmt[\"result\"][\"score\"][\"scaled\"]\n            timestamp = stmt[\"timestamp\"]\n\n            # Create an Achievement instance\n            achievement = Achievement(\n                path=competence_path,\n                level=int(\n                    score_scaled * competence_tree.total_valid_levels\n                ),  # Convert scaled score to level\n                score=stmt[\"result\"][\"score\"][\"raw\"],\n                date_assessed_iso=timestamp,\n            )\n            achievements.append(achievement)\n\n    if actor_id:\n        # Create a Learner instance with these achievements\n        learner = Learner(learner_id=actor_id, achievements=achievements)\n    else:\n        self.warn(\"no learner / actor defined\")\n    return learner\n</code></pre>"}]}